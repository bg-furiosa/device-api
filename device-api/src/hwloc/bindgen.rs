#![allow(warnings)]
/* automatically generated by rust-bindgen 0.59.1 */

pub const HWLOC_VERSION: &'static [u8; 7usize] = b"2.10.0\0";
pub const HWLOC_VERSION_MAJOR: u32 = 2;
pub const HWLOC_VERSION_MINOR: u32 = 10;
pub const HWLOC_VERSION_RELEASE: u32 = 0;
pub const HWLOC_VERSION_GREEK: &'static [u8; 1usize] = b"\0";
pub const GXX_ABOVE_3_4: u32 = 0;
pub const GCC_ABOVE_2_95: u32 = 1;
pub const GCC_ABOVE_2_96: u32 = 1;
pub const GCC_ABOVE_3_3: u32 = 1;
pub const GCC_ABOVE_3_4: u32 = 1;
pub const HWLOC_LINUX_SYS: u32 = 1;
pub const HWLOC_HAVE_CPU_SET: u32 = 1;
pub const _PTHREAD_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const HWLOC_HAVE_STDINT_H: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const HWLOC_SYM_TRANSFORM: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _ASSERT_H: u32 = 1;
pub const HWLOC_API_VERSION: u32 = 133120;
pub const HWLOC_COMPONENT_ABI: u32 = 7;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type size_t = ::std::os::raw::c_ulong;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: size_t,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__low as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__atomic_wide_counter__bindgen_ty_1>())).__high as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__atomic_wide_counter>())).__value32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wseq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__jmpbuf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__mask_was_saved as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__jmp_buf_tag>())).__saved_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CREATE_DETACHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: ::std::os::raw::c_uint = 3;
pub const PTHREAD_MUTEX_NORMAL: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_RECURSIVE: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: ::std::os::raw::c_uint = 2;
pub const PTHREAD_MUTEX_DEFAULT: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_STALLED_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_MUTEX_ROBUST: ::std::os::raw::c_uint = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 1;
pub const PTHREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: ::std::os::raw::c_uint = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: ::std::os::raw::c_uint = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: ::std::os::raw::c_uint = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: ::std::os::raw::c_uint = 0;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_EXPLICIT_SCHED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: ::std::os::raw::c_uint = 0;
pub const PTHREAD_SCOPE_PROCESS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_DISABLE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: ::std::os::raw::c_uint = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__cancel_jmp_buf_tag>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__cancel_jmp_buf_tag>())).__mask_was_saved as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type ssize_t = __ssize_t;
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: size_t,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(
        __buf: *mut ::std::os::raw::c_char,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
pub const _PC_LINK_MAX: ::std::os::raw::c_uint = 0;
pub const _PC_MAX_CANON: ::std::os::raw::c_uint = 1;
pub const _PC_MAX_INPUT: ::std::os::raw::c_uint = 2;
pub const _PC_NAME_MAX: ::std::os::raw::c_uint = 3;
pub const _PC_PATH_MAX: ::std::os::raw::c_uint = 4;
pub const _PC_PIPE_BUF: ::std::os::raw::c_uint = 5;
pub const _PC_CHOWN_RESTRICTED: ::std::os::raw::c_uint = 6;
pub const _PC_NO_TRUNC: ::std::os::raw::c_uint = 7;
pub const _PC_VDISABLE: ::std::os::raw::c_uint = 8;
pub const _PC_SYNC_IO: ::std::os::raw::c_uint = 9;
pub const _PC_ASYNC_IO: ::std::os::raw::c_uint = 10;
pub const _PC_PRIO_IO: ::std::os::raw::c_uint = 11;
pub const _PC_SOCK_MAXBUF: ::std::os::raw::c_uint = 12;
pub const _PC_FILESIZEBITS: ::std::os::raw::c_uint = 13;
pub const _PC_REC_INCR_XFER_SIZE: ::std::os::raw::c_uint = 14;
pub const _PC_REC_MAX_XFER_SIZE: ::std::os::raw::c_uint = 15;
pub const _PC_REC_MIN_XFER_SIZE: ::std::os::raw::c_uint = 16;
pub const _PC_REC_XFER_ALIGN: ::std::os::raw::c_uint = 17;
pub const _PC_ALLOC_SIZE_MIN: ::std::os::raw::c_uint = 18;
pub const _PC_SYMLINK_MAX: ::std::os::raw::c_uint = 19;
pub const _PC_2_SYMLINKS: ::std::os::raw::c_uint = 20;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: ::std::os::raw::c_uint = 0;
pub const _SC_CHILD_MAX: ::std::os::raw::c_uint = 1;
pub const _SC_CLK_TCK: ::std::os::raw::c_uint = 2;
pub const _SC_NGROUPS_MAX: ::std::os::raw::c_uint = 3;
pub const _SC_OPEN_MAX: ::std::os::raw::c_uint = 4;
pub const _SC_STREAM_MAX: ::std::os::raw::c_uint = 5;
pub const _SC_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _SC_JOB_CONTROL: ::std::os::raw::c_uint = 7;
pub const _SC_SAVED_IDS: ::std::os::raw::c_uint = 8;
pub const _SC_REALTIME_SIGNALS: ::std::os::raw::c_uint = 9;
pub const _SC_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 10;
pub const _SC_TIMERS: ::std::os::raw::c_uint = 11;
pub const _SC_ASYNCHRONOUS_IO: ::std::os::raw::c_uint = 12;
pub const _SC_PRIORITIZED_IO: ::std::os::raw::c_uint = 13;
pub const _SC_SYNCHRONIZED_IO: ::std::os::raw::c_uint = 14;
pub const _SC_FSYNC: ::std::os::raw::c_uint = 15;
pub const _SC_MAPPED_FILES: ::std::os::raw::c_uint = 16;
pub const _SC_MEMLOCK: ::std::os::raw::c_uint = 17;
pub const _SC_MEMLOCK_RANGE: ::std::os::raw::c_uint = 18;
pub const _SC_MEMORY_PROTECTION: ::std::os::raw::c_uint = 19;
pub const _SC_MESSAGE_PASSING: ::std::os::raw::c_uint = 20;
pub const _SC_SEMAPHORES: ::std::os::raw::c_uint = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 22;
pub const _SC_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 23;
pub const _SC_AIO_MAX: ::std::os::raw::c_uint = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 25;
pub const _SC_DELAYTIMER_MAX: ::std::os::raw::c_uint = 26;
pub const _SC_MQ_OPEN_MAX: ::std::os::raw::c_uint = 27;
pub const _SC_MQ_PRIO_MAX: ::std::os::raw::c_uint = 28;
pub const _SC_VERSION: ::std::os::raw::c_uint = 29;
pub const _SC_PAGESIZE: ::std::os::raw::c_uint = 30;
pub const _SC_RTSIG_MAX: ::std::os::raw::c_uint = 31;
pub const _SC_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 32;
pub const _SC_SEM_VALUE_MAX: ::std::os::raw::c_uint = 33;
pub const _SC_SIGQUEUE_MAX: ::std::os::raw::c_uint = 34;
pub const _SC_TIMER_MAX: ::std::os::raw::c_uint = 35;
pub const _SC_BC_BASE_MAX: ::std::os::raw::c_uint = 36;
pub const _SC_BC_DIM_MAX: ::std::os::raw::c_uint = 37;
pub const _SC_BC_SCALE_MAX: ::std::os::raw::c_uint = 38;
pub const _SC_BC_STRING_MAX: ::std::os::raw::c_uint = 39;
pub const _SC_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 40;
pub const _SC_EQUIV_CLASS_MAX: ::std::os::raw::c_uint = 41;
pub const _SC_EXPR_NEST_MAX: ::std::os::raw::c_uint = 42;
pub const _SC_LINE_MAX: ::std::os::raw::c_uint = 43;
pub const _SC_RE_DUP_MAX: ::std::os::raw::c_uint = 44;
pub const _SC_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 45;
pub const _SC_2_VERSION: ::std::os::raw::c_uint = 46;
pub const _SC_2_C_BIND: ::std::os::raw::c_uint = 47;
pub const _SC_2_C_DEV: ::std::os::raw::c_uint = 48;
pub const _SC_2_FORT_DEV: ::std::os::raw::c_uint = 49;
pub const _SC_2_FORT_RUN: ::std::os::raw::c_uint = 50;
pub const _SC_2_SW_DEV: ::std::os::raw::c_uint = 51;
pub const _SC_2_LOCALEDEF: ::std::os::raw::c_uint = 52;
pub const _SC_PII: ::std::os::raw::c_uint = 53;
pub const _SC_PII_XTI: ::std::os::raw::c_uint = 54;
pub const _SC_PII_SOCKET: ::std::os::raw::c_uint = 55;
pub const _SC_PII_INTERNET: ::std::os::raw::c_uint = 56;
pub const _SC_PII_OSI: ::std::os::raw::c_uint = 57;
pub const _SC_POLL: ::std::os::raw::c_uint = 58;
pub const _SC_SELECT: ::std::os::raw::c_uint = 59;
pub const _SC_UIO_MAXIOV: ::std::os::raw::c_uint = 60;
pub const _SC_IOV_MAX: ::std::os::raw::c_uint = 60;
pub const _SC_PII_INTERNET_STREAM: ::std::os::raw::c_uint = 61;
pub const _SC_PII_INTERNET_DGRAM: ::std::os::raw::c_uint = 62;
pub const _SC_PII_OSI_COTS: ::std::os::raw::c_uint = 63;
pub const _SC_PII_OSI_CLTS: ::std::os::raw::c_uint = 64;
pub const _SC_PII_OSI_M: ::std::os::raw::c_uint = 65;
pub const _SC_T_IOV_MAX: ::std::os::raw::c_uint = 66;
pub const _SC_THREADS: ::std::os::raw::c_uint = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: ::std::os::raw::c_uint = 68;
pub const _SC_GETGR_R_SIZE_MAX: ::std::os::raw::c_uint = 69;
pub const _SC_GETPW_R_SIZE_MAX: ::std::os::raw::c_uint = 70;
pub const _SC_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 71;
pub const _SC_TTY_NAME_MAX: ::std::os::raw::c_uint = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 73;
pub const _SC_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 74;
pub const _SC_THREAD_STACK_MIN: ::std::os::raw::c_uint = 75;
pub const _SC_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 76;
pub const _SC_THREAD_ATTR_STACKADDR: ::std::os::raw::c_uint = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: ::std::os::raw::c_uint = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: ::std::os::raw::c_uint = 79;
pub const _SC_THREAD_PRIO_INHERIT: ::std::os::raw::c_uint = 80;
pub const _SC_THREAD_PRIO_PROTECT: ::std::os::raw::c_uint = 81;
pub const _SC_THREAD_PROCESS_SHARED: ::std::os::raw::c_uint = 82;
pub const _SC_NPROCESSORS_CONF: ::std::os::raw::c_uint = 83;
pub const _SC_NPROCESSORS_ONLN: ::std::os::raw::c_uint = 84;
pub const _SC_PHYS_PAGES: ::std::os::raw::c_uint = 85;
pub const _SC_AVPHYS_PAGES: ::std::os::raw::c_uint = 86;
pub const _SC_ATEXIT_MAX: ::std::os::raw::c_uint = 87;
pub const _SC_PASS_MAX: ::std::os::raw::c_uint = 88;
pub const _SC_XOPEN_VERSION: ::std::os::raw::c_uint = 89;
pub const _SC_XOPEN_XCU_VERSION: ::std::os::raw::c_uint = 90;
pub const _SC_XOPEN_UNIX: ::std::os::raw::c_uint = 91;
pub const _SC_XOPEN_CRYPT: ::std::os::raw::c_uint = 92;
pub const _SC_XOPEN_ENH_I18N: ::std::os::raw::c_uint = 93;
pub const _SC_XOPEN_SHM: ::std::os::raw::c_uint = 94;
pub const _SC_2_CHAR_TERM: ::std::os::raw::c_uint = 95;
pub const _SC_2_C_VERSION: ::std::os::raw::c_uint = 96;
pub const _SC_2_UPE: ::std::os::raw::c_uint = 97;
pub const _SC_XOPEN_XPG2: ::std::os::raw::c_uint = 98;
pub const _SC_XOPEN_XPG3: ::std::os::raw::c_uint = 99;
pub const _SC_XOPEN_XPG4: ::std::os::raw::c_uint = 100;
pub const _SC_CHAR_BIT: ::std::os::raw::c_uint = 101;
pub const _SC_CHAR_MAX: ::std::os::raw::c_uint = 102;
pub const _SC_CHAR_MIN: ::std::os::raw::c_uint = 103;
pub const _SC_INT_MAX: ::std::os::raw::c_uint = 104;
pub const _SC_INT_MIN: ::std::os::raw::c_uint = 105;
pub const _SC_LONG_BIT: ::std::os::raw::c_uint = 106;
pub const _SC_WORD_BIT: ::std::os::raw::c_uint = 107;
pub const _SC_MB_LEN_MAX: ::std::os::raw::c_uint = 108;
pub const _SC_NZERO: ::std::os::raw::c_uint = 109;
pub const _SC_SSIZE_MAX: ::std::os::raw::c_uint = 110;
pub const _SC_SCHAR_MAX: ::std::os::raw::c_uint = 111;
pub const _SC_SCHAR_MIN: ::std::os::raw::c_uint = 112;
pub const _SC_SHRT_MAX: ::std::os::raw::c_uint = 113;
pub const _SC_SHRT_MIN: ::std::os::raw::c_uint = 114;
pub const _SC_UCHAR_MAX: ::std::os::raw::c_uint = 115;
pub const _SC_UINT_MAX: ::std::os::raw::c_uint = 116;
pub const _SC_ULONG_MAX: ::std::os::raw::c_uint = 117;
pub const _SC_USHRT_MAX: ::std::os::raw::c_uint = 118;
pub const _SC_NL_ARGMAX: ::std::os::raw::c_uint = 119;
pub const _SC_NL_LANGMAX: ::std::os::raw::c_uint = 120;
pub const _SC_NL_MSGMAX: ::std::os::raw::c_uint = 121;
pub const _SC_NL_NMAX: ::std::os::raw::c_uint = 122;
pub const _SC_NL_SETMAX: ::std::os::raw::c_uint = 123;
pub const _SC_NL_TEXTMAX: ::std::os::raw::c_uint = 124;
pub const _SC_XBS5_ILP32_OFF32: ::std::os::raw::c_uint = 125;
pub const _SC_XBS5_ILP32_OFFBIG: ::std::os::raw::c_uint = 126;
pub const _SC_XBS5_LP64_OFF64: ::std::os::raw::c_uint = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: ::std::os::raw::c_uint = 128;
pub const _SC_XOPEN_LEGACY: ::std::os::raw::c_uint = 129;
pub const _SC_XOPEN_REALTIME: ::std::os::raw::c_uint = 130;
pub const _SC_XOPEN_REALTIME_THREADS: ::std::os::raw::c_uint = 131;
pub const _SC_ADVISORY_INFO: ::std::os::raw::c_uint = 132;
pub const _SC_BARRIERS: ::std::os::raw::c_uint = 133;
pub const _SC_BASE: ::std::os::raw::c_uint = 134;
pub const _SC_C_LANG_SUPPORT: ::std::os::raw::c_uint = 135;
pub const _SC_C_LANG_SUPPORT_R: ::std::os::raw::c_uint = 136;
pub const _SC_CLOCK_SELECTION: ::std::os::raw::c_uint = 137;
pub const _SC_CPUTIME: ::std::os::raw::c_uint = 138;
pub const _SC_THREAD_CPUTIME: ::std::os::raw::c_uint = 139;
pub const _SC_DEVICE_IO: ::std::os::raw::c_uint = 140;
pub const _SC_DEVICE_SPECIFIC: ::std::os::raw::c_uint = 141;
pub const _SC_DEVICE_SPECIFIC_R: ::std::os::raw::c_uint = 142;
pub const _SC_FD_MGMT: ::std::os::raw::c_uint = 143;
pub const _SC_FIFO: ::std::os::raw::c_uint = 144;
pub const _SC_PIPE: ::std::os::raw::c_uint = 145;
pub const _SC_FILE_ATTRIBUTES: ::std::os::raw::c_uint = 146;
pub const _SC_FILE_LOCKING: ::std::os::raw::c_uint = 147;
pub const _SC_FILE_SYSTEM: ::std::os::raw::c_uint = 148;
pub const _SC_MONOTONIC_CLOCK: ::std::os::raw::c_uint = 149;
pub const _SC_MULTI_PROCESS: ::std::os::raw::c_uint = 150;
pub const _SC_SINGLE_PROCESS: ::std::os::raw::c_uint = 151;
pub const _SC_NETWORKING: ::std::os::raw::c_uint = 152;
pub const _SC_READER_WRITER_LOCKS: ::std::os::raw::c_uint = 153;
pub const _SC_SPIN_LOCKS: ::std::os::raw::c_uint = 154;
pub const _SC_REGEXP: ::std::os::raw::c_uint = 155;
pub const _SC_REGEX_VERSION: ::std::os::raw::c_uint = 156;
pub const _SC_SHELL: ::std::os::raw::c_uint = 157;
pub const _SC_SIGNALS: ::std::os::raw::c_uint = 158;
pub const _SC_SPAWN: ::std::os::raw::c_uint = 159;
pub const _SC_SPORADIC_SERVER: ::std::os::raw::c_uint = 160;
pub const _SC_THREAD_SPORADIC_SERVER: ::std::os::raw::c_uint = 161;
pub const _SC_SYSTEM_DATABASE: ::std::os::raw::c_uint = 162;
pub const _SC_SYSTEM_DATABASE_R: ::std::os::raw::c_uint = 163;
pub const _SC_TIMEOUTS: ::std::os::raw::c_uint = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: ::std::os::raw::c_uint = 165;
pub const _SC_USER_GROUPS: ::std::os::raw::c_uint = 166;
pub const _SC_USER_GROUPS_R: ::std::os::raw::c_uint = 167;
pub const _SC_2_PBS: ::std::os::raw::c_uint = 168;
pub const _SC_2_PBS_ACCOUNTING: ::std::os::raw::c_uint = 169;
pub const _SC_2_PBS_LOCATE: ::std::os::raw::c_uint = 170;
pub const _SC_2_PBS_MESSAGE: ::std::os::raw::c_uint = 171;
pub const _SC_2_PBS_TRACK: ::std::os::raw::c_uint = 172;
pub const _SC_SYMLOOP_MAX: ::std::os::raw::c_uint = 173;
pub const _SC_STREAMS: ::std::os::raw::c_uint = 174;
pub const _SC_2_PBS_CHECKPOINT: ::std::os::raw::c_uint = 175;
pub const _SC_V6_ILP32_OFF32: ::std::os::raw::c_uint = 176;
pub const _SC_V6_ILP32_OFFBIG: ::std::os::raw::c_uint = 177;
pub const _SC_V6_LP64_OFF64: ::std::os::raw::c_uint = 178;
pub const _SC_V6_LPBIG_OFFBIG: ::std::os::raw::c_uint = 179;
pub const _SC_HOST_NAME_MAX: ::std::os::raw::c_uint = 180;
pub const _SC_TRACE: ::std::os::raw::c_uint = 181;
pub const _SC_TRACE_EVENT_FILTER: ::std::os::raw::c_uint = 182;
pub const _SC_TRACE_INHERIT: ::std::os::raw::c_uint = 183;
pub const _SC_TRACE_LOG: ::std::os::raw::c_uint = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: ::std::os::raw::c_uint = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: ::std::os::raw::c_uint = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: ::std::os::raw::c_uint = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: ::std::os::raw::c_uint = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: ::std::os::raw::c_uint = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: ::std::os::raw::c_uint = 190;
pub const _SC_LEVEL2_CACHE_SIZE: ::std::os::raw::c_uint = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: ::std::os::raw::c_uint = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: ::std::os::raw::c_uint = 193;
pub const _SC_LEVEL3_CACHE_SIZE: ::std::os::raw::c_uint = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: ::std::os::raw::c_uint = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: ::std::os::raw::c_uint = 196;
pub const _SC_LEVEL4_CACHE_SIZE: ::std::os::raw::c_uint = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: ::std::os::raw::c_uint = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: ::std::os::raw::c_uint = 199;
pub const _SC_IPV6: ::std::os::raw::c_uint = 235;
pub const _SC_RAW_SOCKETS: ::std::os::raw::c_uint = 236;
pub const _SC_V7_ILP32_OFF32: ::std::os::raw::c_uint = 237;
pub const _SC_V7_ILP32_OFFBIG: ::std::os::raw::c_uint = 238;
pub const _SC_V7_LP64_OFF64: ::std::os::raw::c_uint = 239;
pub const _SC_V7_LPBIG_OFFBIG: ::std::os::raw::c_uint = 240;
pub const _SC_SS_REPL_MAX: ::std::os::raw::c_uint = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: ::std::os::raw::c_uint = 242;
pub const _SC_TRACE_NAME_MAX: ::std::os::raw::c_uint = 243;
pub const _SC_TRACE_SYS_MAX: ::std::os::raw::c_uint = 244;
pub const _SC_TRACE_USER_EVENT_MAX: ::std::os::raw::c_uint = 245;
pub const _SC_XOPEN_STREAMS: ::std::os::raw::c_uint = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::std::os::raw::c_uint = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::std::os::raw::c_uint = 248;
pub const _SC_MINSIGSTKSZ: ::std::os::raw::c_uint = 249;
pub const _SC_SIGSTKSZ: ::std::os::raw::c_uint = 250;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const _CS_PATH: ::std::os::raw::c_uint = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 1;
pub const _CS_GNU_LIBC_VERSION: ::std::os::raw::c_uint = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: ::std::os::raw::c_uint = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: ::std::os::raw::c_uint = 5;
pub const _CS_LFS_CFLAGS: ::std::os::raw::c_uint = 1000;
pub const _CS_LFS_LDFLAGS: ::std::os::raw::c_uint = 1001;
pub const _CS_LFS_LIBS: ::std::os::raw::c_uint = 1002;
pub const _CS_LFS_LINTFLAGS: ::std::os::raw::c_uint = 1003;
pub const _CS_LFS64_CFLAGS: ::std::os::raw::c_uint = 1004;
pub const _CS_LFS64_LDFLAGS: ::std::os::raw::c_uint = 1005;
pub const _CS_LFS64_LIBS: ::std::os::raw::c_uint = 1006;
pub const _CS_LFS64_LINTFLAGS: ::std::os::raw::c_uint = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: ::std::os::raw::c_uint = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: ::std::os::raw::c_uint = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: ::std::os::raw::c_uint = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: ::std::os::raw::c_uint = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: ::std::os::raw::c_uint = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: ::std::os::raw::c_uint = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: ::std::os::raw::c_uint = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: ::std::os::raw::c_uint = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: ::std::os::raw::c_uint = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: ::std::os::raw::c_uint = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: ::std::os::raw::c_uint = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: ::std::os::raw::c_uint = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: ::std::os::raw::c_uint = 1147;
pub const _CS_V6_ENV: ::std::os::raw::c_uint = 1148;
pub const _CS_V7_ENV: ::std::os::raw::c_uint = 1149;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: size_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: size_t,
        __offset: size_t,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: size_t,
    ) -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type hwloc_uint64_t = u64;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_uint,
        __function: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::std::os::raw::c_char,
        __file: *const ::std::os::raw::c_char,
        __line: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_bitmap_s {
    _unused: [u8; 0],
}
#[doc = " \\brief"]
#[doc = " Set of bits represented as an opaque pointer to an internal bitmap."]
pub type hwloc_bitmap_t = *mut hwloc_bitmap_s;
#[doc = " \\brief a non-modifiable ::hwloc_bitmap_t"]
pub type hwloc_const_bitmap_t = *const hwloc_bitmap_s;
extern "C" {
    #[doc = " \\brief Allocate a new empty bitmap."]
    #[doc = ""]
    #[doc = " \\returns A valid bitmap or \\c NULL."]
    #[doc = ""]
    #[doc = " The bitmap should be freed by a corresponding call to"]
    #[doc = " hwloc_bitmap_free()."]
    pub fn hwloc_bitmap_alloc() -> hwloc_bitmap_t;
}
extern "C" {
    #[doc = " \\brief Allocate a new full bitmap."]
    #[doc = ""]
    #[doc = " \\returns A valid bitmap or \\c NULL."]
    #[doc = ""]
    #[doc = " The bitmap should be freed by a corresponding call to"]
    #[doc = " hwloc_bitmap_free()."]
    pub fn hwloc_bitmap_alloc_full() -> hwloc_bitmap_t;
}
extern "C" {
    #[doc = " \\brief Free bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " If \\p bitmap is \\c NULL, no operation is performed."]
    pub fn hwloc_bitmap_free(bitmap: hwloc_bitmap_t);
}
extern "C" {
    #[doc = " \\brief Duplicate bitmap \\p bitmap by allocating a new bitmap and copying \\p bitmap contents."]
    #[doc = ""]
    #[doc = " If \\p bitmap is \\c NULL, \\c NULL is returned."]
    pub fn hwloc_bitmap_dup(bitmap: hwloc_const_bitmap_t) -> hwloc_bitmap_t;
}
extern "C" {
    #[doc = " \\brief Copy the contents of bitmap \\p src into the already allocated bitmap \\p dst"]
    pub fn hwloc_bitmap_copy(
        dst: hwloc_bitmap_t,
        src: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap."]
    #[doc = ""]
    #[doc = " Up to \\p buflen characters may be written in buffer \\p buf."]
    #[doc = ""]
    #[doc = " If \\p buflen is 0, \\p buf may safely be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return the number of characters that were actually written if not truncating,"]
    #[doc = " or that would have been written (not including the ending \\\\0)."]
    pub fn hwloc_bitmap_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap into a newly allocated string."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_bitmap_asprintf(
        strp: *mut *mut ::std::os::raw::c_char,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Parse a bitmap string and stores it in bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_bitmap_sscanf(
        bitmap: hwloc_bitmap_t,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap in the list format."]
    #[doc = ""]
    #[doc = " Lists are comma-separated indexes or ranges."]
    #[doc = " Ranges are dash separated indexes."]
    #[doc = " The last range may not have an ending indexes if the bitmap is infinitely set."]
    #[doc = ""]
    #[doc = " Up to \\p buflen characters may be written in buffer \\p buf."]
    #[doc = ""]
    #[doc = " If \\p buflen is 0, \\p buf may safely be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return the number of characters that were actually written if not truncating,"]
    #[doc = " or that would have been written (not including the ending \\\\0)."]
    pub fn hwloc_bitmap_list_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap into a newly allocated list string."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_bitmap_list_asprintf(
        strp: *mut *mut ::std::os::raw::c_char,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Parse a list string and stores it in bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_bitmap_list_sscanf(
        bitmap: hwloc_bitmap_t,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap in the taskset-specific format."]
    #[doc = ""]
    #[doc = " The taskset command manipulates bitmap strings that contain a single"]
    #[doc = " (possible very long) hexadecimal number starting with 0x."]
    #[doc = ""]
    #[doc = " Up to \\p buflen characters may be written in buffer \\p buf."]
    #[doc = ""]
    #[doc = " If \\p buflen is 0, \\p buf may safely be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return the number of characters that were actually written if not truncating,"]
    #[doc = " or that would have been written (not including the ending \\\\0)."]
    pub fn hwloc_bitmap_taskset_snprintf(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify a bitmap into a newly allocated taskset-specific string."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_bitmap_taskset_asprintf(
        strp: *mut *mut ::std::os::raw::c_char,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Parse a taskset-specific bitmap string and stores it in bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_bitmap_taskset_sscanf(
        bitmap: hwloc_bitmap_t,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Empty the bitmap \\p bitmap"]
    pub fn hwloc_bitmap_zero(bitmap: hwloc_bitmap_t);
}
extern "C" {
    #[doc = " \\brief Fill bitmap \\p bitmap with all possible indexes (even if those objects don't exist or are otherwise unavailable)"]
    pub fn hwloc_bitmap_fill(bitmap: hwloc_bitmap_t);
}
extern "C" {
    #[doc = " \\brief Empty the bitmap \\p bitmap and add bit \\p id"]
    pub fn hwloc_bitmap_only(
        bitmap: hwloc_bitmap_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Fill the bitmap \\p and clear the index \\p id"]
    pub fn hwloc_bitmap_allbut(
        bitmap: hwloc_bitmap_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Setup bitmap \\p bitmap from unsigned long \\p mask"]
    pub fn hwloc_bitmap_from_ulong(
        bitmap: hwloc_bitmap_t,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Setup bitmap \\p bitmap from unsigned long \\p mask used as \\p i -th subset"]
    pub fn hwloc_bitmap_from_ith_ulong(
        bitmap: hwloc_bitmap_t,
        i: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Setup bitmap \\p bitmap from unsigned longs \\p masks used as first \\p nr subsets"]
    pub fn hwloc_bitmap_from_ulongs(
        bitmap: hwloc_bitmap_t,
        nr: ::std::os::raw::c_uint,
        masks: *const ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add index \\p id in bitmap \\p bitmap"]
    pub fn hwloc_bitmap_set(
        bitmap: hwloc_bitmap_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add indexes from \\p begin to \\p end in bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " If \\p end is \\c -1, the range is infinite."]
    pub fn hwloc_bitmap_set_range(
        bitmap: hwloc_bitmap_t,
        begin: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Replace \\p i -th subset of bitmap \\p bitmap with unsigned long \\p mask"]
    pub fn hwloc_bitmap_set_ith_ulong(
        bitmap: hwloc_bitmap_t,
        i: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Remove index \\p id from bitmap \\p bitmap"]
    pub fn hwloc_bitmap_clr(
        bitmap: hwloc_bitmap_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Remove indexes from \\p begin to \\p end in bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " If \\p end is \\c -1, the range is infinite."]
    pub fn hwloc_bitmap_clr_range(
        bitmap: hwloc_bitmap_t,
        begin: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Keep a single index among those set in bitmap \\p bitmap"]
    #[doc = ""]
    #[doc = " May be useful before binding so that the process does not"]
    #[doc = " have a chance of migrating between multiple processors"]
    #[doc = " in the original mask."]
    #[doc = " Instead of running the task on any PU inside the given CPU set,"]
    #[doc = " the operating system scheduler will be forced to run it on a single"]
    #[doc = " of these PUs."]
    #[doc = " It avoids a migration overhead and cache-line ping-pongs between PUs."]
    #[doc = ""]
    #[doc = " \\note This function is NOT meant to distribute multiple processes"]
    #[doc = " within a single CPU set. It always return the same single bit when"]
    #[doc = " called multiple times on the same input set. hwloc_distrib() may"]
    #[doc = " be used for generating CPU sets to distribute multiple tasks below"]
    #[doc = " a single multi-PU object."]
    #[doc = ""]
    #[doc = " \\note This function cannot be applied to an object set directly. It"]
    #[doc = " should be applied to a copy (which may be obtained with hwloc_bitmap_dup())."]
    pub fn hwloc_bitmap_singlify(bitmap: hwloc_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Convert the beginning part of bitmap \\p bitmap into unsigned long \\p mask"]
    pub fn hwloc_bitmap_to_ulong(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " \\brief Convert the \\p i -th subset of bitmap \\p bitmap into unsigned long mask"]
    pub fn hwloc_bitmap_to_ith_ulong(
        bitmap: hwloc_const_bitmap_t,
        i: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " \\brief Convert the first \\p nr subsets of bitmap \\p bitmap into the array of \\p nr unsigned long \\p masks"]
    #[doc = ""]
    #[doc = " \\p nr may be determined earlier with hwloc_bitmap_nr_ulongs()."]
    #[doc = ""]
    #[doc = " \\return 0"]
    pub fn hwloc_bitmap_to_ulongs(
        bitmap: hwloc_const_bitmap_t,
        nr: ::std::os::raw::c_uint,
        masks: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the number of unsigned longs required for storing bitmap \\p bitmap entirely"]
    #[doc = ""]
    #[doc = " This is the number of contiguous unsigned longs from the very first bit of the bitmap"]
    #[doc = " (even if unset) up to the last set bit."]
    #[doc = " This is useful for knowing the \\p nr parameter to pass to hwloc_bitmap_to_ulongs()"]
    #[doc = " (or which calls to hwloc_bitmap_to_ith_ulong() are needed)"]
    #[doc = " to entirely convert a bitmap into multiple unsigned longs."]
    #[doc = ""]
    #[doc = " When called on the output of hwloc_topology_get_topology_cpuset(),"]
    #[doc = " the returned number is large enough for all cpusets of the topology."]
    #[doc = ""]
    #[doc = " \\return the number of unsigned longs required."]
    #[doc = " \\return -1 if \\p bitmap is infinite."]
    pub fn hwloc_bitmap_nr_ulongs(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether index \\p id is part of bitmap \\p bitmap."]
    #[doc = ""]
    #[doc = " \\return 1 if the bit at index \\p id is set in bitmap \\p bitmap, 0 otherwise."]
    pub fn hwloc_bitmap_isset(
        bitmap: hwloc_const_bitmap_t,
        id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether bitmap \\p bitmap is empty"]
    #[doc = ""]
    #[doc = " \\return 1 if bitmap is empty, 0 otherwise."]
    pub fn hwloc_bitmap_iszero(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether bitmap \\p bitmap is completely full"]
    #[doc = ""]
    #[doc = " \\return 1 if bitmap is full, 0 otherwise."]
    #[doc = ""]
    #[doc = " \\note A full bitmap is always infinitely set."]
    pub fn hwloc_bitmap_isfull(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the first index (least significant bit) in bitmap \\p bitmap"]
    #[doc = ""]
    #[doc = " \\return the first index set in \\p bitmap."]
    #[doc = " \\return -1 if \\p bitmap is empty."]
    pub fn hwloc_bitmap_first(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the next index in bitmap \\p bitmap which is after index \\p prev"]
    #[doc = ""]
    #[doc = " \\return the first index set in \\p bitmap if \\p prev is \\c -1."]
    #[doc = " \\return the next index set in \\p bitmap if \\p prev is not \\c -1."]
    #[doc = " \\return -1 if no index with higher index is set in \\p bitmap."]
    pub fn hwloc_bitmap_next(
        bitmap: hwloc_const_bitmap_t,
        prev: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the last index (most significant bit) in bitmap \\p bitmap"]
    #[doc = ""]
    #[doc = " \\return the last index set in \\p bitmap."]
    #[doc = " \\return -1 if \\p bitmap is empty, or if \\p bitmap is infinitely set."]
    pub fn hwloc_bitmap_last(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the \"weight\" of bitmap \\p bitmap (i.e., number of"]
    #[doc = " indexes that are in the bitmap)."]
    #[doc = ""]
    #[doc = " \\return the number of indexes that are in the bitmap."]
    #[doc = " \\return -1 if \\p bitmap is infinitely set."]
    pub fn hwloc_bitmap_weight(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the first unset index (least significant bit) in bitmap \\p bitmap"]
    #[doc = ""]
    #[doc = " \\return the first unset index in \\p bitmap."]
    #[doc = " \\return -1 if \\p bitmap is full."]
    pub fn hwloc_bitmap_first_unset(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the next unset index in bitmap \\p bitmap which is after index \\p prev"]
    #[doc = ""]
    #[doc = " \\return the first index unset in \\p bitmap if \\p prev is \\c -1."]
    #[doc = " \\return the next index unset in \\p bitmap if \\p prev is not \\c -1."]
    #[doc = " \\return -1 if no index with higher index is unset in \\p bitmap."]
    pub fn hwloc_bitmap_next_unset(
        bitmap: hwloc_const_bitmap_t,
        prev: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compute the last unset index (most significant bit) in bitmap \\p bitmap"]
    #[doc = ""]
    #[doc = " \\return the last index unset in \\p bitmap."]
    #[doc = " \\return -1 if \\p bitmap is full, or if \\p bitmap is not infinitely set."]
    pub fn hwloc_bitmap_last_unset(bitmap: hwloc_const_bitmap_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Or bitmaps \\p bitmap1 and \\p bitmap2 and store the result in bitmap \\p res"]
    #[doc = ""]
    #[doc = " \\p res can be the same as \\p bitmap1 or \\p bitmap2"]
    pub fn hwloc_bitmap_or(
        res: hwloc_bitmap_t,
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief And bitmaps \\p bitmap1 and \\p bitmap2 and store the result in bitmap \\p res"]
    #[doc = ""]
    #[doc = " \\p res can be the same as \\p bitmap1 or \\p bitmap2"]
    pub fn hwloc_bitmap_and(
        res: hwloc_bitmap_t,
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief And bitmap \\p bitmap1 and the negation of \\p bitmap2 and store the result in bitmap \\p res"]
    #[doc = ""]
    #[doc = " \\p res can be the same as \\p bitmap1 or \\p bitmap2"]
    pub fn hwloc_bitmap_andnot(
        res: hwloc_bitmap_t,
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Xor bitmaps \\p bitmap1 and \\p bitmap2 and store the result in bitmap \\p res"]
    #[doc = ""]
    #[doc = " \\p res can be the same as \\p bitmap1 or \\p bitmap2"]
    pub fn hwloc_bitmap_xor(
        res: hwloc_bitmap_t,
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Negate bitmap \\p bitmap and store the result in bitmap \\p res"]
    #[doc = ""]
    #[doc = " \\p res can be the same as \\p bitmap"]
    pub fn hwloc_bitmap_not(
        res: hwloc_bitmap_t,
        bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether bitmaps \\p bitmap1 and \\p bitmap2 intersects."]
    #[doc = ""]
    #[doc = " \\return 1 if bitmaps intersect, 0 otherwise."]
    #[doc = ""]
    #[doc = " \\note The empty bitmap does not intersect any other bitmap."]
    pub fn hwloc_bitmap_intersects(
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether bitmap \\p sub_bitmap is part of bitmap \\p super_bitmap."]
    #[doc = ""]
    #[doc = " \\return 1 if \\p sub_bitmap is included in \\p super_bitmap, 0 otherwise."]
    #[doc = ""]
    #[doc = " \\note The empty bitmap is considered included in any other bitmap."]
    pub fn hwloc_bitmap_isincluded(
        sub_bitmap: hwloc_const_bitmap_t,
        super_bitmap: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Test whether bitmap \\p bitmap1 is equal to bitmap \\p bitmap2."]
    #[doc = ""]
    #[doc = " \\return 1 if bitmaps are equal, 0 otherwise."]
    pub fn hwloc_bitmap_isequal(
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compare bitmaps \\p bitmap1 and \\p bitmap2 using their lowest index."]
    #[doc = ""]
    #[doc = " A bitmap is considered smaller if its least significant bit is smaller."]
    #[doc = " The empty bitmap is considered higher than anything (because its least significant bit does not exist)."]
    #[doc = ""]
    #[doc = " \\return -1 if \\p bitmap1 is considered smaller than \\p bitmap2."]
    #[doc = " \\return 1 if \\p bitmap1 is considered larger than \\p bitmap2."]
    #[doc = ""]
    #[doc = " For instance comparing binary bitmaps 0011 and 0110 returns -1"]
    #[doc = " (hence 0011 is considered smaller than 0110)"]
    #[doc = " because least significant bit of 0011 (0001) is smaller than least significant bit of 0110 (0010)."]
    #[doc = " Comparing 01001 and 00110 would also return -1 for the same reason."]
    #[doc = ""]
    #[doc = " \\return 0 if bitmaps are considered equal, even if they are not strictly equal."]
    #[doc = " They just need to have the same least significant bit."]
    #[doc = " For instance, comparing binary bitmaps 0010 and 0110 returns 0 because they have the same least significant bit."]
    pub fn hwloc_bitmap_compare_first(
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Compare bitmaps \\p bitmap1 and \\p bitmap2 in lexicographic order."]
    #[doc = ""]
    #[doc = " Lexicographic comparison of bitmaps, starting for their highest indexes."]
    #[doc = " Compare last indexes first, then second, etc."]
    #[doc = " The empty bitmap is considered lower than anything."]
    #[doc = ""]
    #[doc = " \\return -1 if \\p bitmap1 is considered smaller than \\p bitmap2."]
    #[doc = " \\return 1 if \\p bitmap1 is considered larger than \\p bitmap2."]
    #[doc = " \\return 0 if bitmaps are equal (contrary to hwloc_bitmap_compare_first())."]
    #[doc = ""]
    #[doc = " For instance comparing binary bitmaps 0011 and 0110 returns -1"]
    #[doc = " (hence 0011 is considered smaller than 0110)."]
    #[doc = " Comparing 00101 and 01010 returns -1 too."]
    #[doc = ""]
    #[doc = " \\note This is different from the non-existing hwloc_bitmap_compare_last()"]
    #[doc = " which would only compare the highest index of each bitmap."]
    pub fn hwloc_bitmap_compare(
        bitmap1: hwloc_const_bitmap_t,
        bitmap2: hwloc_const_bitmap_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Indicate at runtime which hwloc API version was used at build time."]
    #[doc = ""]
    #[doc = " Should be ::HWLOC_API_VERSION if running on the same version."]
    #[doc = ""]
    #[doc = " \\return the build-time version number."]
    pub fn hwloc_get_api_version() -> ::std::os::raw::c_uint;
}
#[doc = " \\brief A CPU set is a bitmap whose bits are set according to CPU"]
#[doc = " physical OS indexes."]
#[doc = ""]
#[doc = " It may be consulted and modified with the bitmap API as any"]
#[doc = " ::hwloc_bitmap_t (see hwloc/bitmap.h)."]
#[doc = ""]
#[doc = " Each bit may be converted into a PU object using"]
#[doc = " hwloc_get_pu_obj_by_os_index()."]
pub type hwloc_cpuset_t = hwloc_bitmap_t;
#[doc = " \\brief A non-modifiable ::hwloc_cpuset_t."]
pub type hwloc_const_cpuset_t = hwloc_const_bitmap_t;
#[doc = " \\brief A node set is a bitmap whose bits are set according to NUMA"]
#[doc = " memory node physical OS indexes."]
#[doc = ""]
#[doc = " It may be consulted and modified with the bitmap API as any"]
#[doc = " ::hwloc_bitmap_t (see hwloc/bitmap.h)."]
#[doc = " Each bit may be converted into a NUMA node object using"]
#[doc = " hwloc_get_numanode_obj_by_os_index()."]
#[doc = ""]
#[doc = " When binding memory on a system without any NUMA node,"]
#[doc = " the single main memory bank is considered as NUMA node #0."]
#[doc = ""]
#[doc = " See also \\ref hwlocality_helper_nodeset_convert."]
pub type hwloc_nodeset_t = hwloc_bitmap_t;
#[doc = " \\brief A non-modifiable ::hwloc_nodeset_t."]
pub type hwloc_const_nodeset_t = hwloc_const_bitmap_t;
#[doc = "< \\brief Machine."]
#[doc = " A set of processors and memory with cache"]
#[doc = " coherency."]
#[doc = ""]
#[doc = " This type is always used for the root object of a topology,"]
#[doc = " and never used anywhere else."]
#[doc = " Hence its parent is always \\c NULL."]
pub const hwloc_obj_type_t_HWLOC_OBJ_MACHINE: hwloc_obj_type_t = 0;
#[doc = "< \\brief Physical package."]
#[doc = " The physical package that usually gets inserted"]
#[doc = " into a socket on the motherboard."]
#[doc = " A processor package usually contains multiple cores,"]
#[doc = " and possibly some dies."]
pub const hwloc_obj_type_t_HWLOC_OBJ_PACKAGE: hwloc_obj_type_t = 1;
#[doc = "< \\brief Core."]
#[doc = " A computation unit (may be shared by several"]
#[doc = " PUs, aka logical processors)."]
pub const hwloc_obj_type_t_HWLOC_OBJ_CORE: hwloc_obj_type_t = 2;
#[doc = "< \\brief Processing Unit, or (Logical) Processor."]
#[doc = " An execution unit (may share a core with some"]
#[doc = " other logical processors, e.g. in the case of"]
#[doc = " an SMT core)."]
#[doc = ""]
#[doc = " This is the smallest object representing CPU resources,"]
#[doc = " it cannot have any child except Misc objects."]
#[doc = ""]
#[doc = " Objects of this kind are always reported and can"]
#[doc = " thus be used as fallback when others are not."]
pub const hwloc_obj_type_t_HWLOC_OBJ_PU: hwloc_obj_type_t = 3;
#[doc = "< \\brief Level 1 Data (or Unified) Cache."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L1CACHE: hwloc_obj_type_t = 4;
#[doc = "< \\brief Level 2 Data (or Unified) Cache."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L2CACHE: hwloc_obj_type_t = 5;
#[doc = "< \\brief Level 3 Data (or Unified) Cache."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L3CACHE: hwloc_obj_type_t = 6;
#[doc = "< \\brief Level 4 Data (or Unified) Cache."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L4CACHE: hwloc_obj_type_t = 7;
#[doc = "< \\brief Level 5 Data (or Unified) Cache."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L5CACHE: hwloc_obj_type_t = 8;
#[doc = "< \\brief Level 1 instruction Cache (filtered out by default)."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L1ICACHE: hwloc_obj_type_t = 9;
#[doc = "< \\brief Level 2 instruction Cache (filtered out by default)."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L2ICACHE: hwloc_obj_type_t = 10;
#[doc = "< \\brief Level 3 instruction Cache (filtered out by default)."]
pub const hwloc_obj_type_t_HWLOC_OBJ_L3ICACHE: hwloc_obj_type_t = 11;
#[doc = "< \\brief Group objects."]
#[doc = " Objects which do not fit in the above but are"]
#[doc = " detected by hwloc and are useful to take into"]
#[doc = " account for affinity. For instance, some operating systems"]
#[doc = " expose their arbitrary processors aggregation this"]
#[doc = " way.  And hwloc may insert such objects to group"]
#[doc = " NUMA nodes according to their distances."]
#[doc = " See also \\ref faq_groups."]
#[doc = ""]
#[doc = " These objects are removed when they do not bring"]
#[doc = " any structure (see ::HWLOC_TYPE_FILTER_KEEP_STRUCTURE)."]
pub const hwloc_obj_type_t_HWLOC_OBJ_GROUP: hwloc_obj_type_t = 12;
#[doc = "< \\brief NUMA node."]
#[doc = " An object that contains memory that is directly"]
#[doc = " and byte-accessible to the host processors."]
#[doc = " It is usually close to some cores (the corresponding objects"]
#[doc = " are descendants of the NUMA node object in the hwloc tree)."]
#[doc = ""]
#[doc = " This is the smallest object representing Memory resources,"]
#[doc = " it cannot have any child except Misc objects."]
#[doc = " However it may have Memory-side cache parents."]
#[doc = ""]
#[doc = " NUMA nodes may correspond to different kinds of memory"]
#[doc = " (DRAM, HBM, CXL-DRAM, etc.). When hwloc is able to guess"]
#[doc = " that kind, it is specified in the subtype field of the object."]
#[doc = " See also \\ref attributes_normal in the main documentation."]
#[doc = ""]
#[doc = " There is always at least one such object in the topology"]
#[doc = " even if the machine is not NUMA."]
#[doc = ""]
#[doc = " Memory objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated Memory children list."]
#[doc = ""]
#[doc = " NUMA nodes have a special depth ::HWLOC_TYPE_DEPTH_NUMANODE"]
#[doc = " instead of a normal depth just like other objects in the"]
#[doc = " main tree."]
pub const hwloc_obj_type_t_HWLOC_OBJ_NUMANODE: hwloc_obj_type_t = 13;
#[doc = "< \\brief Bridge (filtered out by default)."]
#[doc = " Any bridge (or PCI switch) that connects the host or an I/O bus,"]
#[doc = " to another I/O bus."]
#[doc = ""]
#[doc = " Bridges are not added to the topology unless their"]
#[doc = " filtering is changed (see hwloc_topology_set_type_filter()"]
#[doc = " and hwloc_topology_set_io_types_filter())."]
#[doc = ""]
#[doc = " I/O objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated io children list."]
#[doc = " I/O objects have NULL CPU and node sets."]
pub const hwloc_obj_type_t_HWLOC_OBJ_BRIDGE: hwloc_obj_type_t = 14;
#[doc = "< \\brief PCI device (filtered out by default)."]
#[doc = ""]
#[doc = " PCI devices are not added to the topology unless their"]
#[doc = " filtering is changed (see hwloc_topology_set_type_filter()"]
#[doc = " and hwloc_topology_set_io_types_filter())."]
#[doc = ""]
#[doc = " I/O objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated io children list."]
#[doc = " I/O objects have NULL CPU and node sets."]
pub const hwloc_obj_type_t_HWLOC_OBJ_PCI_DEVICE: hwloc_obj_type_t = 15;
#[doc = "< \\brief Operating system device (filtered out by default)."]
#[doc = ""]
#[doc = " OS devices are not added to the topology unless their"]
#[doc = " filtering is changed (see hwloc_topology_set_type_filter()"]
#[doc = " and hwloc_topology_set_io_types_filter())."]
#[doc = ""]
#[doc = " I/O objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated io children list."]
#[doc = " I/O objects have NULL CPU and node sets."]
pub const hwloc_obj_type_t_HWLOC_OBJ_OS_DEVICE: hwloc_obj_type_t = 16;
#[doc = "< \\brief Miscellaneous objects (filtered out by default)."]
#[doc = " Objects without particular meaning, that can e.g. be"]
#[doc = " added by the application for its own use, or by hwloc"]
#[doc = " for miscellaneous objects such as MemoryModule (DIMMs)."]
#[doc = ""]
#[doc = " They are not added to the topology unless their filtering"]
#[doc = " is changed (see hwloc_topology_set_type_filter())."]
#[doc = ""]
#[doc = " These objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated misc children list."]
#[doc = " Misc objects may only have Misc objects as children,"]
#[doc = " and those are in the dedicated misc children list as well."]
#[doc = " Misc objects have NULL CPU and node sets."]
pub const hwloc_obj_type_t_HWLOC_OBJ_MISC: hwloc_obj_type_t = 17;
#[doc = "< \\brief Memory-side cache (filtered out by default)."]
#[doc = " A cache in front of a specific NUMA node."]
#[doc = ""]
#[doc = " This object always has at least one NUMA node as a memory child."]
#[doc = ""]
#[doc = " Memory objects are not listed in the main children list,"]
#[doc = " but rather in the dedicated Memory children list."]
#[doc = ""]
#[doc = " Memory-side cache have a special depth ::HWLOC_TYPE_DEPTH_MEMCACHE"]
#[doc = " instead of a normal depth just like other objects in the"]
#[doc = " main tree."]
pub const hwloc_obj_type_t_HWLOC_OBJ_MEMCACHE: hwloc_obj_type_t = 18;
#[doc = "< \\brief Die within a physical package."]
#[doc = " A subpart of the physical package, that contains multiple cores."]
#[doc = ""]
#[doc = " Some operating systems (e.g. Linux) may expose a single die per package"]
#[doc = " even if the hardware does not support dies at all. To avoid showing"]
#[doc = " such non-existing dies, the corresponding hwloc backend may filter them out."]
#[doc = " This is functionally equivalent to ::HWLOC_TYPE_FILTER_KEEP_STRUCTURE"]
#[doc = " being enforced."]
pub const hwloc_obj_type_t_HWLOC_OBJ_DIE: hwloc_obj_type_t = 19;
#[doc = "< \\private Sentinel value"]
pub const hwloc_obj_type_t_HWLOC_OBJ_TYPE_MAX: hwloc_obj_type_t = 20;
#[doc = " \\brief Type of topology object."]
#[doc = ""]
#[doc = " \\note Do not rely on the ordering or completeness of the values as new ones"]
#[doc = " may be defined in the future!  If you need to compare types, use"]
#[doc = " hwloc_compare_types() instead."]
pub type hwloc_obj_type_t = ::std::os::raw::c_uint;
#[doc = "< \\brief Unified cache."]
pub const hwloc_obj_cache_type_e_HWLOC_OBJ_CACHE_UNIFIED: hwloc_obj_cache_type_e = 0;
#[doc = "< \\brief Data cache."]
pub const hwloc_obj_cache_type_e_HWLOC_OBJ_CACHE_DATA: hwloc_obj_cache_type_e = 1;
#[doc = "< \\brief Instruction cache (filtered out by default)."]
pub const hwloc_obj_cache_type_e_HWLOC_OBJ_CACHE_INSTRUCTION: hwloc_obj_cache_type_e = 2;
#[doc = " \\brief Cache type."]
pub type hwloc_obj_cache_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Cache type."]
pub use self::hwloc_obj_cache_type_e as hwloc_obj_cache_type_t;
#[doc = "< \\brief Host-side of a bridge, only possible upstream."]
pub const hwloc_obj_bridge_type_e_HWLOC_OBJ_BRIDGE_HOST: hwloc_obj_bridge_type_e = 0;
#[doc = "< \\brief PCI-side of a bridge."]
pub const hwloc_obj_bridge_type_e_HWLOC_OBJ_BRIDGE_PCI: hwloc_obj_bridge_type_e = 1;
#[doc = " \\brief Type of one side (upstream or downstream) of an I/O bridge."]
pub type hwloc_obj_bridge_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Type of one side (upstream or downstream) of an I/O bridge."]
pub use self::hwloc_obj_bridge_type_e as hwloc_obj_bridge_type_t;
#[doc = "< \\brief Operating system block device, or non-volatile memory device."]
#[doc = " For instance \"sda\" or \"dax2.0\" on Linux."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_BLOCK: hwloc_obj_osdev_type_e = 0;
#[doc = "< \\brief Operating system GPU device."]
#[doc = " For instance \":0.0\" for a GL display,"]
#[doc = " \"card0\" for a Linux DRM device."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_GPU: hwloc_obj_osdev_type_e = 1;
#[doc = "< \\brief Operating system network device."]
#[doc = " For instance the \"eth0\" interface on Linux."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_NETWORK: hwloc_obj_osdev_type_e = 2;
#[doc = "< \\brief Operating system openfabrics device."]
#[doc = " For instance the \"mlx4_0\" InfiniBand HCA,"]
#[doc = " \"hfi1_0\" Omni-Path interface,"]
#[doc = " or \"bxi0\" Atos/Bull BXI HCA on Linux."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_OPENFABRICS: hwloc_obj_osdev_type_e = 3;
#[doc = "< \\brief Operating system dma engine device."]
#[doc = " For instance the \"dma0chan0\" DMA channel on Linux."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_DMA: hwloc_obj_osdev_type_e = 4;
#[doc = "< \\brief Operating system co-processor device."]
#[doc = " For instance \"opencl0d0\" for a OpenCL device,"]
#[doc = " \"cuda0\" for a CUDA device."]
pub const hwloc_obj_osdev_type_e_HWLOC_OBJ_OSDEV_COPROC: hwloc_obj_osdev_type_e = 5;
#[doc = " \\brief Type of a OS device."]
pub type hwloc_obj_osdev_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Type of a OS device."]
pub use self::hwloc_obj_osdev_type_e as hwloc_obj_osdev_type_t;
extern "C" {
    #[doc = " \\brief Compare the depth of two object types"]
    #[doc = ""]
    #[doc = " Types shouldn't be compared as they are, since newer ones may be added in"]
    #[doc = " the future."]
    #[doc = ""]
    #[doc = " \\return A negative integer if \\p type1 objects usually include \\p type2 objects."]
    #[doc = " \\return A positive integer if \\p type1 objects are usually included in \\p type2 objects."]
    #[doc = " \\return 0 if \\p type1 and \\p type2 objects are the same."]
    #[doc = " \\return ::HWLOC_TYPE_UNORDERED if objects cannot be compared"]
    #[doc = " (because neither is usually contained in the other)."]
    #[doc = ""]
    #[doc = " \\note Object types containing CPUs can always be compared"]
    #[doc = " (usually, a machine contains packages, which contain caches,"]
    #[doc = "  which contain cores, which contain PUs)."]
    #[doc = ""]
    #[doc = " \\note ::HWLOC_OBJ_PU will always be the deepest,"]
    #[doc = " while ::HWLOC_OBJ_MACHINE is always the highest."]
    #[doc = ""]
    #[doc = " \\note This does not mean that the actual topology will respect that order:"]
    #[doc = " e.g. as of today cores may also contain caches, and packages may also contain"]
    #[doc = " nodes. This is thus just to be seen as a fallback comparison method."]
    pub fn hwloc_compare_types(
        type1: hwloc_obj_type_t,
        type2: hwloc_obj_type_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Structure of a topology object"]
#[doc = ""]
#[doc = " Applications must not modify any field except \\p hwloc_obj.userdata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj {
    #[doc = "< \\brief Type of object"]
    pub type_: hwloc_obj_type_t,
    #[doc = "< \\brief Subtype string to better describe the type field."]
    pub subtype: *mut ::std::os::raw::c_char,
    #[doc = "< \\brief OS-provided physical index number."]
    #[doc = " It is not guaranteed unique across the entire machine,"]
    #[doc = " except for PUs and NUMA nodes."]
    #[doc = " Set to HWLOC_UNKNOWN_INDEX if unknown or irrelevant for this object."]
    pub os_index: ::std::os::raw::c_uint,
    #[doc = "< \\brief Object-specific name if any."]
    #[doc = " Mostly used for identifying OS devices and Misc objects where"]
    #[doc = " a name string is more useful than numerical indexes."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< \\brief Total memory (in bytes) in NUMA nodes below this object."]
    pub total_memory: hwloc_uint64_t,
    #[doc = "< \\brief Object type-specific Attributes,"]
    #[doc = " may be \\c NULL if no attribute value was found"]
    pub attr: *mut hwloc_obj_attr_u,
    #[doc = "< \\brief Vertical index in the hierarchy."]
    #[doc = ""]
    #[doc = " For normal objects, this is the depth of the horizontal level"]
    #[doc = " that contains this object and its cousins of the same type."]
    #[doc = " If the topology is symmetric, this is equal to the parent depth"]
    #[doc = " plus one, and also equal to the number of parent/child links"]
    #[doc = " from the root object to here."]
    #[doc = ""]
    #[doc = " For special objects (NUMA nodes, I/O and Misc) that are not"]
    #[doc = " in the main tree, this is a special negative value that"]
    #[doc = " corresponds to their dedicated level,"]
    #[doc = " see hwloc_get_type_depth() and ::hwloc_get_type_depth_e."]
    #[doc = " Those special values can be passed to hwloc functions such"]
    #[doc = " hwloc_get_nbobjs_by_depth() as usual."]
    pub depth: ::std::os::raw::c_int,
    #[doc = "< \\brief Horizontal index in the whole list of similar objects,"]
    #[doc = " hence guaranteed unique across the entire machine."]
    #[doc = " Could be a \"cousin_rank\" since it's the rank within the \"cousin\" list below"]
    #[doc = " Note that this index may change when restricting the topology"]
    #[doc = " or when inserting a group."]
    pub logical_index: ::std::os::raw::c_uint,
    #[doc = "< \\brief Next object of same type and depth"]
    pub next_cousin: *mut hwloc_obj,
    #[doc = "< \\brief Previous object of same type and depth"]
    pub prev_cousin: *mut hwloc_obj,
    #[doc = "< \\brief Parent, \\c NULL if root (Machine object)"]
    pub parent: *mut hwloc_obj,
    #[doc = "< \\brief Index in parent's \\c children[] array. Or the index in parent's Memory, I/O or Misc children list."]
    pub sibling_rank: ::std::os::raw::c_uint,
    #[doc = "< \\brief Next object below the same parent (inside the same list of children)."]
    pub next_sibling: *mut hwloc_obj,
    #[doc = "< \\brief Previous object below the same parent (inside the same list of children)."]
    pub prev_sibling: *mut hwloc_obj,
    #[doc = "< \\brief Number of normal children."]
    #[doc = " Memory, Misc and I/O children are not listed here"]
    #[doc = " but rather in their dedicated children list."]
    pub arity: ::std::os::raw::c_uint,
    #[doc = "< \\brief Normal children, \\c children[0 .. arity -1]"]
    pub children: *mut *mut hwloc_obj,
    #[doc = "< \\brief First normal child"]
    pub first_child: *mut hwloc_obj,
    #[doc = "< \\brief Last normal child"]
    pub last_child: *mut hwloc_obj,
    #[doc = "< \\brief Set if the subtree of normal objects below this object is symmetric,"]
    #[doc = " which means all normal children and their children have identical subtrees."]
    #[doc = ""]
    #[doc = " Memory, I/O and Misc children are ignored."]
    #[doc = ""]
    #[doc = " If set in the topology root object, lstopo may export the topology"]
    #[doc = " as a synthetic string."]
    pub symmetric_subtree: ::std::os::raw::c_int,
    #[doc = "< \\brief Number of Memory children."]
    #[doc = " These children are listed in \\p memory_first_child."]
    pub memory_arity: ::std::os::raw::c_uint,
    #[doc = "< \\brief First Memory child."]
    #[doc = " NUMA nodes and Memory-side caches are listed here"]
    #[doc = " (\\p memory_arity and \\p memory_first_child)"]
    #[doc = " instead of in the normal children list."]
    #[doc = " See also hwloc_obj_type_is_memory()."]
    #[doc = ""]
    #[doc = " A memory hierarchy starts from a normal CPU-side object"]
    #[doc = " (e.g. Package) and ends with NUMA nodes as leaves."]
    #[doc = " There might exist some memory-side caches between them"]
    #[doc = " in the middle of the memory subtree."]
    pub memory_first_child: *mut hwloc_obj,
    #[doc = "< \\brief Number of I/O children."]
    #[doc = " These children are listed in \\p io_first_child."]
    pub io_arity: ::std::os::raw::c_uint,
    #[doc = "< \\brief First I/O child."]
    #[doc = " Bridges, PCI and OS devices are listed here (\\p io_arity and \\p io_first_child)"]
    #[doc = " instead of in the normal children list."]
    #[doc = " See also hwloc_obj_type_is_io()."]
    pub io_first_child: *mut hwloc_obj,
    #[doc = "< \\brief Number of Misc children."]
    #[doc = " These children are listed in \\p misc_first_child."]
    pub misc_arity: ::std::os::raw::c_uint,
    #[doc = "< \\brief First Misc child."]
    #[doc = " Misc objects are listed here (\\p misc_arity and \\p misc_first_child)"]
    #[doc = " instead of in the normal children list."]
    pub misc_first_child: *mut hwloc_obj,
    #[doc = "< \\brief CPUs covered by this object"]
    #[doc = ""]
    #[doc = " This is the set of CPUs for which there are PU objects in the topology"]
    #[doc = " under this object, i.e. which are known to be physically contained in this"]
    #[doc = " object and known how (the children path between this object and the PU"]
    #[doc = " objects)."]
    #[doc = ""]
    #[doc = " If the ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED configuration flag is set,"]
    #[doc = " some of these CPUs may be online but not allowed for binding,"]
    #[doc = " see hwloc_topology_get_allowed_cpuset()."]
    #[doc = ""]
    #[doc = " \\note All objects have non-NULL CPU and node sets except Misc and I/O objects."]
    #[doc = ""]
    #[doc = " \\note Its value must not be changed, hwloc_bitmap_dup() must be used instead."]
    pub cpuset: hwloc_cpuset_t,
    #[doc = "< \\brief The complete CPU set of processors of this object,"]
    #[doc = ""]
    #[doc = " This may include not only the same as the cpuset field, but also some CPUs for"]
    #[doc = " which topology information is unknown or incomplete, some offlines CPUs, and"]
    #[doc = " the CPUs that are ignored when the ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED flag"]
    #[doc = " is not set."]
    #[doc = " Thus no corresponding PU object may be found in the topology, because the"]
    #[doc = " precise position is undefined. It is however known that it would be somewhere"]
    #[doc = " under this object."]
    #[doc = ""]
    #[doc = " \\note Its value must not be changed, hwloc_bitmap_dup() must be used instead."]
    pub complete_cpuset: hwloc_cpuset_t,
    #[doc = "< \\brief NUMA nodes covered by this object or containing this object"]
    #[doc = ""]
    #[doc = " This is the set of NUMA nodes for which there are NUMA node objects in the"]
    #[doc = " topology under or above this object, i.e. which are known to be physically"]
    #[doc = " contained in this object or containing it and known how (the children path"]
    #[doc = " between this object and the NUMA node objects)."]
    #[doc = ""]
    #[doc = " In the end, these nodes are those that are close to the current object."]
    #[doc = " Function hwloc_get_local_numanode_objs() may be used to list those NUMA"]
    #[doc = " nodes more precisely."]
    #[doc = ""]
    #[doc = " If the ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED configuration flag is set,"]
    #[doc = " some of these nodes may be online but not allowed for allocation,"]
    #[doc = " see hwloc_topology_get_allowed_nodeset()."]
    #[doc = ""]
    #[doc = " If there are no NUMA nodes in the machine, all the memory is close to this"]
    #[doc = " object, so only the first bit may be set in \\p nodeset."]
    #[doc = ""]
    #[doc = " \\note All objects have non-NULL CPU and node sets except Misc and I/O objects."]
    #[doc = ""]
    #[doc = " \\note Its value must not be changed, hwloc_bitmap_dup() must be used instead."]
    pub nodeset: hwloc_nodeset_t,
    #[doc = "< \\brief The complete NUMA node set of this object,"]
    #[doc = ""]
    #[doc = " This may include not only the same as the nodeset field, but also some NUMA"]
    #[doc = " nodes for which topology information is unknown or incomplete, some offlines"]
    #[doc = " nodes, and the nodes that are ignored when the ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED"]
    #[doc = " flag is not set."]
    #[doc = " Thus no corresponding NUMA node object may be found in the topology, because the"]
    #[doc = " precise position is undefined. It is however known that it would be"]
    #[doc = " somewhere under this object."]
    #[doc = ""]
    #[doc = " If there are no NUMA nodes in the machine, all the memory is close to this"]
    #[doc = " object, so only the first bit is set in \\p complete_nodeset."]
    #[doc = ""]
    #[doc = " \\note Its value must not be changed, hwloc_bitmap_dup() must be used instead."]
    pub complete_nodeset: hwloc_nodeset_t,
    #[doc = "< \\brief Array of info attributes (name and value strings)."]
    pub infos: *mut hwloc_info_s,
    #[doc = "< \\brief Size of infos array."]
    pub infos_count: ::std::os::raw::c_uint,
    #[doc = "< \\brief Application-given private data pointer,"]
    #[doc = " initialized to \\c NULL, use it as you wish."]
    #[doc = " See hwloc_topology_set_userdata_export_callback() in hwloc/export.h"]
    #[doc = " if you wish to export this field to XML."]
    pub userdata: *mut ::std::os::raw::c_void,
    #[doc = "< \\brief Global persistent index."]
    #[doc = " Generated by hwloc, unique across the topology (contrary to os_index)"]
    #[doc = " and persistent across topology changes (contrary to logical_index)."]
    #[doc = " Mostly used internally, but could also be used by application to identify objects."]
    pub gp_index: hwloc_uint64_t,
}
#[test]
fn bindgen_test_layout_hwloc_obj() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj>(),
        248usize,
        concat!("Size of: ", stringify!(hwloc_obj))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_obj))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).subtype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).os_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(os_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).total_memory as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(total_memory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).attr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).depth as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).logical_index as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(logical_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).next_cousin as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(next_cousin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).prev_cousin as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(prev_cousin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).parent as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).sibling_rank as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(sibling_rank)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).next_sibling as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(next_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).prev_sibling as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(prev_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).arity as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(arity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).children as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).first_child as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(first_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).last_child as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(last_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).symmetric_subtree as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(symmetric_subtree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).memory_arity as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(memory_arity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).memory_first_child as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(memory_first_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).io_arity as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(io_arity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).io_first_child as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(io_first_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).misc_arity as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(misc_arity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).misc_first_child as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(misc_first_child)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).cpuset as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(cpuset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).complete_cpuset as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(complete_cpuset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).nodeset as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(nodeset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).complete_nodeset as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(complete_nodeset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).infos as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(infos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).infos_count as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(infos_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).userdata as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj>())).gp_index as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj),
            "::",
            stringify!(gp_index)
        )
    );
}
#[doc = " \\brief Convenience typedef; a pointer to a struct hwloc_obj."]
pub type hwloc_obj_t = *mut hwloc_obj;
#[doc = " \\defgroup hwlocality_objects Object Structure and Attributes"]
#[doc = " @{"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_obj_attr_u {
    pub numanode: hwloc_obj_attr_u_hwloc_numanode_attr_s,
    pub cache: hwloc_obj_attr_u_hwloc_cache_attr_s,
    pub group: hwloc_obj_attr_u_hwloc_group_attr_s,
    pub pcidev: hwloc_obj_attr_u_hwloc_pcidev_attr_s,
    pub bridge: hwloc_obj_attr_u_hwloc_bridge_attr_s,
    pub osdev: hwloc_obj_attr_u_hwloc_osdev_attr_s,
}
#[doc = " \\brief NUMA node-specific Object Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_numanode_attr_s {
    #[doc = "< \\brief Local memory (in bytes)"]
    pub local_memory: hwloc_uint64_t,
    #[doc = "< \\brief Size of array \\p page_types"]
    pub page_types_len: ::std::os::raw::c_uint,
    pub page_types: *mut hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s,
}
#[doc = " \\brief Array of local memory page types, \\c NULL if no local memory and \\p page_types is 0."]
#[doc = ""]
#[doc = " The array is sorted by increasing \\p size fields."]
#[doc = " It contains \\p page_types_len slots."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s {
    #[doc = "< \\brief Size of pages"]
    pub size: hwloc_uint64_t,
    #[doc = "< \\brief Number of pages of this size"]
    pub count: hwloc_uint64_t,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s>(
            )))
            .size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s>(
            )))
            .count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s_hwloc_memory_page_type_s),
            "::",
            stringify!(count)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_numanode_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_numanode_attr_s>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_numanode_attr_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_numanode_attr_s>())).local_memory
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s),
            "::",
            stringify!(local_memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_numanode_attr_s>())).page_types_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s),
            "::",
            stringify!(page_types_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_numanode_attr_s>())).page_types
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_numanode_attr_s),
            "::",
            stringify!(page_types)
        )
    );
}
#[doc = " \\brief Cache-specific Object Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_cache_attr_s {
    #[doc = "< \\brief Size of cache in bytes"]
    pub size: hwloc_uint64_t,
    #[doc = "< \\brief Depth of cache (e.g., L1, L2, ...etc.)"]
    pub depth: ::std::os::raw::c_uint,
    #[doc = "< \\brief Cache-line size in bytes. 0 if unknown"]
    pub linesize: ::std::os::raw::c_uint,
    #[doc = "< \\brief Ways of associativity,"]
    #[doc = "  -1 if fully associative, 0 if unknown"]
    pub associativity: ::std::os::raw::c_int,
    #[doc = "< \\brief Cache type"]
    pub type_: hwloc_obj_cache_type_t,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_cache_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_cache_attr_s>(),
        24usize,
        concat!("Size of: ", stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_cache_attr_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_cache_attr_s>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_cache_attr_s>())).depth as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_cache_attr_s>())).linesize as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_cache_attr_s>())).associativity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s),
            "::",
            stringify!(associativity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_cache_attr_s>())).type_ as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_cache_attr_s),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " \\brief Group-specific Object Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_group_attr_s {
    #[doc = "< \\brief Depth of group object."]
    #[doc = "   It may change if intermediate Group objects are added."]
    pub depth: ::std::os::raw::c_uint,
    #[doc = "< \\brief Internally-used kind of group."]
    pub kind: ::std::os::raw::c_uint,
    #[doc = "< \\brief Internally-used subkind to distinguish different levels of groups with same kind"]
    pub subkind: ::std::os::raw::c_uint,
    #[doc = "< \\brief Flag preventing groups from being automatically merged with identical parent or children."]
    pub dont_merge: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_group_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_group_attr_s>(),
        16usize,
        concat!("Size of: ", stringify!(hwloc_obj_attr_u_hwloc_group_attr_s))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_group_attr_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_group_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_group_attr_s>())).depth as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_group_attr_s),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_group_attr_s>())).kind as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_group_attr_s),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_group_attr_s>())).subkind as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_group_attr_s),
            "::",
            stringify!(subkind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_group_attr_s>())).dont_merge as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_group_attr_s),
            "::",
            stringify!(dont_merge)
        )
    );
}
#[doc = " \\brief PCI Device specific Object Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_pcidev_attr_s {
    #[doc = "< \\brief Domain number (xxxx in the PCI BDF notation xxxx:yy:zz.t)."]
    #[doc = "   Only 16bits PCI domains are supported by default."]
    pub domain: ::std::os::raw::c_ushort,
    #[doc = "< \\brief Bus number      (yy   in the PCI BDF notation xxxx:yy:zz.t)."]
    pub bus: ::std::os::raw::c_uchar,
    #[doc = "< \\brief Device number   (zz   in the PCI BDF notation xxxx:yy:zz.t)."]
    pub dev: ::std::os::raw::c_uchar,
    #[doc = "< \\brief Function number (t    in the PCI BDF notation xxxx:yy:zz.t)."]
    pub func: ::std::os::raw::c_uchar,
    #[doc = "< \\brief The class number (first two bytes, without the prog_if)."]
    pub class_id: ::std::os::raw::c_ushort,
    #[doc = "< \\brief Vendor ID (xxxx in [xxxx:yyyy])."]
    pub vendor_id: ::std::os::raw::c_ushort,
    #[doc = "< \\brief Device ID (yyyy in [xxxx:yyyy])."]
    pub device_id: ::std::os::raw::c_ushort,
    #[doc = "< \\brief Sub-Vendor ID."]
    pub subvendor_id: ::std::os::raw::c_ushort,
    #[doc = "< \\brief Sub-Device ID."]
    pub subdevice_id: ::std::os::raw::c_ushort,
    #[doc = "< \\brief Revision number."]
    pub revision: ::std::os::raw::c_uchar,
    #[doc = "< \\brief Link speed in GB/s."]
    #[doc = "   This datarate is the currently configured speed of the entire PCI link"]
    #[doc = "   (sum of the bandwidth of all PCI lanes in that link)."]
    #[doc = "   It may change during execution since some devices are able to"]
    #[doc = "   slow their PCI links down when idle."]
    pub linkspeed: f32,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_pcidev_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).domain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).bus as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).dev as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).func as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).class_id as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(class_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).vendor_id as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).device_id as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).subvendor_id
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(subvendor_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).subdevice_id
                as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(subdevice_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).revision as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_pcidev_attr_s>())).linkspeed as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_pcidev_attr_s),
            "::",
            stringify!(linkspeed)
        )
    );
}
#[doc = " \\brief Bridge specific Object Attributes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_bridge_attr_s {
    pub upstream: hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1,
    #[doc = "< \\brief Upstream Bridge type."]
    pub upstream_type: hwloc_obj_bridge_type_t,
    pub downstream: hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2,
    #[doc = "< \\brief Downstream Bridge type."]
    pub downstream_type: hwloc_obj_bridge_type_t,
    pub depth: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1 {
    #[doc = "< \\brief PCI attribute of the upstream part as a PCI device."]
    pub pci: hwloc_obj_attr_u_hwloc_pcidev_attr_s,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1>())).pci
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_1),
            "::",
            stringify!(pci)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2 {
    pub pci: hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1 {
    #[doc = "< \\brief Domain number the downstream PCI buses."]
    #[doc = "   Only 16bits PCI domains are supported by default."]
    pub domain: ::std::os::raw::c_ushort,
    #[doc = "< \\brief First PCI bus number below the bridge."]
    pub secondary_bus: ::std::os::raw::c_uchar,
    #[doc = "< \\brief Highest PCI bus number below the bridge."]
    pub subordinate_bus: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            & (* (:: std :: ptr :: null :: < hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1 > ())) . domain as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe {
            & (* (:: std :: ptr :: null :: < hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1 > ())) . secondary_bus as * const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(secondary_bus)
        )
    );
    assert_eq!(
        unsafe {
            & (* (:: std :: ptr :: null :: < hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1 > ())) . subordinate_bus as * const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(subordinate_bus)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2>())).pci
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s__bindgen_ty_2),
            "::",
            stringify!(pci)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_bridge_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_bridge_attr_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s>())).upstream as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s),
            "::",
            stringify!(upstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s>())).upstream_type
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s),
            "::",
            stringify!(upstream_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s>())).downstream as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s),
            "::",
            stringify!(downstream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s>())).downstream_type
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s),
            "::",
            stringify!(downstream_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_bridge_attr_s>())).depth as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_bridge_attr_s),
            "::",
            stringify!(depth)
        )
    );
}
#[doc = " \\brief OS Device specific Object Attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_obj_attr_u_hwloc_osdev_attr_s {
    pub type_: hwloc_obj_osdev_type_t,
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u_hwloc_osdev_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u_hwloc_osdev_attr_s>(),
        4usize,
        concat!("Size of: ", stringify!(hwloc_obj_attr_u_hwloc_osdev_attr_s))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u_hwloc_osdev_attr_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_obj_attr_u_hwloc_osdev_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_obj_attr_u_hwloc_osdev_attr_s>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u_hwloc_osdev_attr_s),
            "::",
            stringify!(type_)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_obj_attr_u() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_obj_attr_u>(),
        40usize,
        concat!("Size of: ", stringify!(hwloc_obj_attr_u))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_obj_attr_u>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_obj_attr_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).numanode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(numanode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).cache as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).pcidev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(pcidev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).bridge as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(bridge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_obj_attr_u>())).osdev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_obj_attr_u),
            "::",
            stringify!(osdev)
        )
    );
}
#[doc = " \\brief Object info attribute (name and value strings)"]
#[doc = ""]
#[doc = " \\sa hwlocality_info_attr"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_info_s {
    #[doc = "< \\brief Info name"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< \\brief Info value"]
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hwloc_info_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_info_s>(),
        16usize,
        concat!("Size of: ", stringify!(hwloc_info_s))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_info_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_info_s>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_info_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_info_s>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_info_s),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " \\defgroup hwlocality_creation Topology Creation and Destruction"]
#[doc = " @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology {
    _unused: [u8; 0],
}
#[doc = " \\brief Topology context"]
#[doc = ""]
#[doc = " To be initialized with hwloc_topology_init() and built with hwloc_topology_load()."]
pub type hwloc_topology_t = *mut hwloc_topology;
extern "C" {
    #[doc = " \\brief Allocate a topology context."]
    #[doc = ""]
    #[doc = " \\param[out] topologyp is assigned a pointer to the new allocated context."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_topology_init(topologyp: *mut hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Build the actual topology"]
    #[doc = ""]
    #[doc = " Build the actual topology once initialized with hwloc_topology_init() and"]
    #[doc = " tuned with \\ref hwlocality_configuration and \\ref hwlocality_setsource routines."]
    #[doc = " No other routine may be called earlier using this topology context."]
    #[doc = ""]
    #[doc = " \\param topology is the topology to be loaded with objects."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\note On failure, the topology is reinitialized. It should be either"]
    #[doc = " destroyed with hwloc_topology_destroy() or configured and loaded again."]
    #[doc = ""]
    #[doc = " \\note This function may be called only once per topology."]
    #[doc = ""]
    #[doc = " \\note The binding of the current thread or process may temporarily change"]
    #[doc = " during this call but it will be restored before it returns."]
    #[doc = ""]
    #[doc = " \\sa hwlocality_configuration and hwlocality_setsource"]
    pub fn hwloc_topology_load(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Terminate and free a topology context"]
    #[doc = ""]
    #[doc = " \\param topology is the topology to be freed"]
    pub fn hwloc_topology_destroy(topology: hwloc_topology_t);
}
extern "C" {
    #[doc = " \\brief Duplicate a topology."]
    #[doc = ""]
    #[doc = " The entire topology structure as well as its objects"]
    #[doc = " are duplicated into a new one."]
    #[doc = ""]
    #[doc = " This is useful for keeping a backup while modifying a topology."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\note Object userdata is not duplicated since hwloc does not know what it point to."]
    #[doc = " The objects of both old and new topologies will point to the same userdata."]
    pub fn hwloc_topology_dup(
        newtopology: *mut hwloc_topology_t,
        oldtopology: hwloc_topology_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Verify that the topology is compatible with the current hwloc library."]
    #[doc = ""]
    #[doc = " This is useful when using the same topology structure (in memory)"]
    #[doc = " in different libraries that may use different hwloc installations"]
    #[doc = " (for instance if one library embeds a specific version of hwloc,"]
    #[doc = " while another library uses a default system-wide hwloc installation)."]
    #[doc = ""]
    #[doc = " If all libraries/programs use the same hwloc installation, this function"]
    #[doc = " always returns success."]
    #[doc = ""]
    #[doc = " \\return \\c 0 on success."]
    #[doc = ""]
    #[doc = " \\return \\c -1 with \\p errno set to \\c EINVAL if incompatible."]
    #[doc = ""]
    #[doc = " \\note If sharing between processes with hwloc_shmem_topology_write(),"]
    #[doc = " the relevant check is already performed inside hwloc_shmem_topology_adopt()."]
    pub fn hwloc_topology_abi_check(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Run internal checks on a topology structure"]
    #[doc = ""]
    #[doc = " The program aborts if an inconsistency is detected in the given topology."]
    #[doc = ""]
    #[doc = " \\param topology is the topology to be checked"]
    #[doc = ""]
    #[doc = " \\note This routine is only useful to developers."]
    #[doc = ""]
    #[doc = " \\note The input topology should have been previously loaded with"]
    #[doc = " hwloc_topology_load()."]
    pub fn hwloc_topology_check(topology: hwloc_topology_t);
}
extern "C" {
    #[doc = " \\brief Get the depth of the hierarchical tree of objects."]
    #[doc = ""]
    #[doc = " This is the depth of ::HWLOC_OBJ_PU objects plus one."]
    #[doc = ""]
    #[doc = " \\return the depth of the object tree."]
    #[doc = ""]
    #[doc = " \\note NUMA nodes, I/O and Misc objects are ignored when computing"]
    #[doc = " the depth of the tree (they are placed on special levels)."]
    pub fn hwloc_topology_get_depth(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the depth of objects of type \\p type."]
    #[doc = ""]
    #[doc = " \\return The depth of objects of type \\p type."]
    #[doc = ""]
    #[doc = " \\return A negative virtual depth if a NUMA node, I/O or Misc object type is given."]
    #[doc = " These objects are stored in special levels that are not CPU-related."]
    #[doc = " This virtual depth may be passed to other hwloc functions such as"]
    #[doc = " hwloc_get_obj_by_depth() but it should not be considered as an actual"]
    #[doc = " depth by the application. In particular, it should not be compared with"]
    #[doc = " any other object depth or with the entire topology depth."]
    #[doc = ""]
    #[doc = " \\return ::HWLOC_TYPE_DEPTH_UNKNOWN"]
    #[doc = " if no object of this type is present on the underlying architecture,"]
    #[doc = " or if the OS doesn't provide this kind of information."]
    #[doc = ""]
    #[doc = " \\return ::HWLOC_TYPE_DEPTH_MULTIPLE if type ::HWLOC_OBJ_GROUP is given"]
    #[doc = " and multiple levels of Groups exist."]
    #[doc = ""]
    #[doc = " \\note If the type is absent but a similar type is acceptable, see also"]
    #[doc = " hwloc_get_type_or_below_depth() and hwloc_get_type_or_above_depth()."]
    #[doc = ""]
    #[doc = " \\sa hwloc_get_memory_parents_depth() for managing the depth of memory objects."]
    #[doc = ""]
    #[doc = " \\sa hwloc_type_sscanf_as_depth() for returning the depth of objects"]
    #[doc = " whose type is given as a string."]
    pub fn hwloc_get_type_depth(
        topology: hwloc_topology_t,
        type_: hwloc_obj_type_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< \\brief No object of given type exists in the topology. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_UNKNOWN: hwloc_get_type_depth_e = -1;
#[doc = "< \\brief Objects of given type exist at different depth in the topology (only for Groups). \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_MULTIPLE: hwloc_get_type_depth_e = -2;
#[doc = "< \\brief Virtual depth for NUMA nodes. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_NUMANODE: hwloc_get_type_depth_e = -3;
#[doc = "< \\brief Virtual depth for bridge object level. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_BRIDGE: hwloc_get_type_depth_e = -4;
#[doc = "< \\brief Virtual depth for PCI device object level. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_PCI_DEVICE: hwloc_get_type_depth_e = -5;
#[doc = "< \\brief Virtual depth for software device object level. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_OS_DEVICE: hwloc_get_type_depth_e = -6;
#[doc = "< \\brief Virtual depth for Misc object. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_MISC: hwloc_get_type_depth_e = -7;
#[doc = "< \\brief Virtual depth for MemCache object. \\hideinitializer"]
pub const hwloc_get_type_depth_e_HWLOC_TYPE_DEPTH_MEMCACHE: hwloc_get_type_depth_e = -8;
pub type hwloc_get_type_depth_e = ::std::os::raw::c_int;
extern "C" {
    #[doc = " \\brief Return the depth of parents where memory objects are attached."]
    #[doc = ""]
    #[doc = " Memory objects have virtual negative depths because they are not part of"]
    #[doc = " the main CPU-side hierarchy of objects. This depth should not be compared"]
    #[doc = " with other level depths."]
    #[doc = ""]
    #[doc = " If all Memory objects are attached to Normal parents at the same depth,"]
    #[doc = " this parent depth may be compared to other as usual, for instance"]
    #[doc = " for knowing whether NUMA nodes is attached above or below Packages."]
    #[doc = ""]
    #[doc = " \\return The depth of Normal parents of all memory children"]
    #[doc = " if all these parents have the same depth. For instance the depth of"]
    #[doc = " the Package level if all NUMA nodes are attached to Package objects."]
    #[doc = ""]
    #[doc = " \\return ::HWLOC_TYPE_DEPTH_MULTIPLE if Normal parents of all"]
    #[doc = " memory children do not have the same depth. For instance if some"]
    #[doc = " NUMA nodes are attached to Packages while others are attached to"]
    #[doc = " Groups."]
    pub fn hwloc_get_memory_parents_depth(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Returns the type of objects at depth \\p depth."]
    #[doc = ""]
    #[doc = " \\p depth should between 0 and hwloc_topology_get_depth()-1,"]
    #[doc = " or a virtual depth such as ::HWLOC_TYPE_DEPTH_NUMANODE."]
    #[doc = ""]
    #[doc = " \\return The type of objects at depth \\p depth."]
    #[doc = " \\return (hwloc_obj_type_t)-1 if depth \\p depth does not exist."]
    pub fn hwloc_get_depth_type(
        topology: hwloc_topology_t,
        depth: ::std::os::raw::c_int,
    ) -> hwloc_obj_type_t;
}
extern "C" {
    #[doc = " \\brief Returns the width of level at depth \\p depth."]
    #[doc = ""]
    #[doc = " \\return The number of objects at topology depth \\p depth."]
    #[doc = " \\return 0 if there are no objects at depth \\p depth."]
    pub fn hwloc_get_nbobjs_by_depth(
        topology: hwloc_topology_t,
        depth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " \\brief Returns the topology object at logical index \\p idx from depth \\p depth"]
    #[doc = ""]
    #[doc = " \\return The object if it exists."]
    #[doc = " \\return \\c NULL if there is no object with this index and depth."]
    pub fn hwloc_get_obj_by_depth(
        topology: hwloc_topology_t,
        depth: ::std::os::raw::c_int,
        idx: ::std::os::raw::c_uint,
    ) -> hwloc_obj_t;
}
extern "C" {
    #[doc = " \\brief Return a constant stringified object type."]
    #[doc = ""]
    #[doc = " This function is the basic way to convert a generic type into a string."]
    #[doc = " The output string may be parsed back by hwloc_type_sscanf()."]
    #[doc = ""]
    #[doc = " hwloc_obj_type_snprintf() may return a more precise output for a specific"]
    #[doc = " object, but it requires the caller to provide the output buffer."]
    #[doc = ""]
    #[doc = " \\return A constant string containing the object type name or \\c \"Unknown\"."]
    pub fn hwloc_obj_type_string(type_: hwloc_obj_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \\brief Stringify the type of a given topology object into a human-readable form."]
    #[doc = ""]
    #[doc = " Contrary to hwloc_obj_type_string(), this function includes object-specific"]
    #[doc = " attributes (such as the Group depth, the Bridge type, or OS device type)"]
    #[doc = " in the output, and it requires the caller to provide the output buffer."]
    #[doc = ""]
    #[doc = " The output is guaranteed to be the same for all objects of a same topology level."]
    #[doc = ""]
    #[doc = " If \\p verbose is 1, longer type names are used, e.g. L1Cache instead of L1."]
    #[doc = ""]
    #[doc = " The output string may be parsed back by hwloc_type_sscanf()."]
    #[doc = ""]
    #[doc = " If \\p size is 0, \\p string may safely be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return the number of characters that were actually written if not truncating,"]
    #[doc = " or that would have been written (not including the ending \\\\0)."]
    pub fn hwloc_obj_type_snprintf(
        string: *mut ::std::os::raw::c_char,
        size: size_t,
        obj: hwloc_obj_t,
        verbose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Stringify the attributes of a given topology object into a human-readable form."]
    #[doc = ""]
    #[doc = " Attribute values are separated by \\p separator."]
    #[doc = ""]
    #[doc = " Only the major attributes are printed in non-verbose mode."]
    #[doc = ""]
    #[doc = " If \\p size is 0, \\p string may safely be \\c NULL."]
    #[doc = ""]
    #[doc = " \\return the number of characters that were actually written if not truncating,"]
    #[doc = " or that would have been written (not including the ending \\\\0)."]
    pub fn hwloc_obj_attr_snprintf(
        string: *mut ::std::os::raw::c_char,
        size: size_t,
        obj: hwloc_obj_t,
        separator: *const ::std::os::raw::c_char,
        verbose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return an object type and attributes from a type string."]
    #[doc = ""]
    #[doc = " Convert strings such as \"Package\" or \"L1iCache\" into the corresponding types."]
    #[doc = " Matching is case-insensitive, and only the first letters are actually"]
    #[doc = " required to match."]
    #[doc = ""]
    #[doc = " The matched object type is set in \\p typep (which cannot be \\c NULL)."]
    #[doc = ""]
    #[doc = " Type-specific attributes, for instance Cache type, Cache depth, Group depth,"]
    #[doc = " Bridge type or OS Device type may be returned in \\p attrp."]
    #[doc = " Attributes that are not specified in the string (for instance \"Group\""]
    #[doc = " without a depth, or \"L2Cache\" without a cache type) are set to -1."]
    #[doc = ""]
    #[doc = " \\p attrp is only filled if not \\c NULL and if its size specified in \\p attrsize"]
    #[doc = " is large enough. It should be at least as large as union hwloc_obj_attr_u."]
    #[doc = ""]
    #[doc = " \\return 0 if a type was correctly identified, otherwise -1."]
    #[doc = ""]
    #[doc = " \\note This function is guaranteed to match any string returned by"]
    #[doc = " hwloc_obj_type_string() or hwloc_obj_type_snprintf()."]
    #[doc = ""]
    #[doc = " \\note This is an extended version of the now deprecated hwloc_obj_type_sscanf()."]
    pub fn hwloc_type_sscanf(
        string: *const ::std::os::raw::c_char,
        typep: *mut hwloc_obj_type_t,
        attrp: *mut hwloc_obj_attr_u,
        attrsize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return an object type and its level depth from a type string."]
    #[doc = ""]
    #[doc = " Convert strings such as \"Package\" or \"L1iCache\" into the corresponding types"]
    #[doc = " and return in \\p depthp the depth of the corresponding level in the"]
    #[doc = " topology \\p topology."]
    #[doc = ""]
    #[doc = " If no object of this type is present on the underlying architecture,"]
    #[doc = " ::HWLOC_TYPE_DEPTH_UNKNOWN is returned."]
    #[doc = ""]
    #[doc = " If multiple such levels exist (for instance if giving Group without any depth),"]
    #[doc = " the function may return ::HWLOC_TYPE_DEPTH_MULTIPLE instead."]
    #[doc = ""]
    #[doc = " The matched object type is set in \\p typep if \\p typep is non \\c NULL."]
    #[doc = ""]
    #[doc = " \\note This function is similar to hwloc_type_sscanf() followed"]
    #[doc = " by hwloc_get_type_depth() but it also automatically disambiguates"]
    #[doc = " multiple group levels etc."]
    #[doc = ""]
    #[doc = " \\note This function is guaranteed to match any string returned by"]
    #[doc = " hwloc_obj_type_string() or hwloc_obj_type_snprintf()."]
    pub fn hwloc_type_sscanf_as_depth(
        string: *const ::std::os::raw::c_char,
        typep: *mut hwloc_obj_type_t,
        topology: hwloc_topology_t,
        depthp: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add the given name and value pair to the given object info attributes."]
    #[doc = ""]
    #[doc = " The info pair is appended to the existing info array even if another pair"]
    #[doc = " with the same name already exists."]
    #[doc = ""]
    #[doc = " The input strings are copied before being added in the object infos."]
    #[doc = ""]
    #[doc = " \\return \\c 0 on success, \\c -1 on error."]
    #[doc = ""]
    #[doc = " \\note This function may be used to enforce object colors in the lstopo"]
    #[doc = " graphical output by adding \"lstopoStyle\" as a name and \"Background=#rrggbb\""]
    #[doc = " as a value. See CUSTOM COLORS in the lstopo(1) manpage for details."]
    #[doc = ""]
    #[doc = " \\note If \\p name or \\p value contain some non-printable characters, they will"]
    #[doc = " be dropped when exporting to XML, see hwloc_topology_export_xml() in hwloc/export.h."]
    pub fn hwloc_obj_add_info(
        obj: hwloc_obj_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Bind all threads of the current (possibly) multithreaded process."]
#[doc = " \\hideinitializer"]
pub const hwloc_cpubind_flags_t_HWLOC_CPUBIND_PROCESS: hwloc_cpubind_flags_t = 1;
#[doc = " \\brief Bind current thread of current process."]
#[doc = " \\hideinitializer"]
pub const hwloc_cpubind_flags_t_HWLOC_CPUBIND_THREAD: hwloc_cpubind_flags_t = 2;
#[doc = " \\brief Request for strict binding from the OS."]
#[doc = ""]
#[doc = " By default, when the designated CPUs are all busy while other"]
#[doc = " CPUs are idle, operating systems may execute the thread/process"]
#[doc = " on those other CPUs instead of the designated CPUs, to let them"]
#[doc = " progress anyway.  Strict binding means that the thread/process"]
#[doc = " will _never_ execute on other CPUs than the designated CPUs, even"]
#[doc = " when those are busy with other tasks and other CPUs are idle."]
#[doc = ""]
#[doc = " \\note Depending on the operating system, strict binding may not"]
#[doc = " be possible (e.g., the OS does not implement it) or not allowed"]
#[doc = " (e.g., for an administrative reasons), and the function will fail"]
#[doc = " in that case."]
#[doc = ""]
#[doc = " When retrieving the binding of a process, this flag checks"]
#[doc = " whether all its threads  actually have the same binding. If the"]
#[doc = " flag is not given, the binding of each thread will be"]
#[doc = " accumulated."]
#[doc = ""]
#[doc = " \\note This flag is meaningless when retrieving the binding of a"]
#[doc = " thread."]
#[doc = " \\hideinitializer"]
pub const hwloc_cpubind_flags_t_HWLOC_CPUBIND_STRICT: hwloc_cpubind_flags_t = 4;
#[doc = " \\brief Avoid any effect on memory binding"]
#[doc = ""]
#[doc = " On some operating systems, some CPU binding function would also"]
#[doc = " bind the memory on the corresponding NUMA node.  It is often not"]
#[doc = " a problem for the application, but if it is, setting this flag"]
#[doc = " will make hwloc avoid using OS functions that would also bind"]
#[doc = " memory.  This will however reduce the support of CPU bindings,"]
#[doc = " i.e. potentially return -1 with errno set to \\c ENOSYS in some"]
#[doc = " cases."]
#[doc = ""]
#[doc = " This flag is only meaningful when used with functions that set"]
#[doc = " the CPU binding.  It is ignored when used with functions that get"]
#[doc = " CPU binding information."]
#[doc = " \\hideinitializer"]
pub const hwloc_cpubind_flags_t_HWLOC_CPUBIND_NOMEMBIND: hwloc_cpubind_flags_t = 8;
#[doc = " \\brief Process/Thread binding flags."]
#[doc = ""]
#[doc = " These bit flags can be used to refine the binding policy."]
#[doc = ""]
#[doc = " The default (0) is to bind the current process, assumed to be"]
#[doc = " single-threaded, in a non-strict way.  This is the most portable"]
#[doc = " way to bind as all operating systems usually provide it."]
#[doc = ""]
#[doc = " \\note Not all systems support all kinds of binding.  See the"]
#[doc = " \"Detailed Description\" section of \\ref hwlocality_cpubinding for a"]
#[doc = " description of errors that can occur."]
pub type hwloc_cpubind_flags_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Bind current process or thread on CPUs given in physical bitmap \\p set."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c ENOSYS if the action is not supported."]
    #[doc = " \\return -1 with errno set to \\c EXDEV if the binding cannot be enforced."]
    pub fn hwloc_set_cpubind(
        topology: hwloc_topology_t,
        set: hwloc_const_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get current process or thread binding."]
    #[doc = ""]
    #[doc = " The CPU-set \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the list of PUs which the process or"]
    #[doc = " thread (according to \\e flags) was last bound to."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_get_cpubind(
        topology: hwloc_topology_t,
        set: hwloc_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Bind a process \\p pid on CPUs given in physical bitmap \\p set."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note As a special case on Linux, if a tid (thread ID) is supplied"]
    #[doc = " instead of a pid (process ID) and ::HWLOC_CPUBIND_THREAD is passed in flags,"]
    #[doc = " the binding is applied to that specific thread."]
    #[doc = ""]
    #[doc = " \\note On non-Linux systems, ::HWLOC_CPUBIND_THREAD can not be used in \\p flags."]
    pub fn hwloc_set_proc_cpubind(
        topology: hwloc_topology_t,
        pid: pid_t,
        set: hwloc_const_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the current physical binding of process \\p pid."]
    #[doc = ""]
    #[doc = " The CPU-set \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the list of PUs which the process"]
    #[doc = " was last bound to."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note As a special case on Linux, if a tid (thread ID) is supplied"]
    #[doc = " instead of a pid (process ID) and HWLOC_CPUBIND_THREAD is passed in flags,"]
    #[doc = " the binding for that specific thread is returned."]
    #[doc = ""]
    #[doc = " \\note On non-Linux systems, HWLOC_CPUBIND_THREAD can not be used in \\p flags."]
    pub fn hwloc_get_proc_cpubind(
        topology: hwloc_topology_t,
        pid: pid_t,
        set: hwloc_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Bind a thread \\p thread on CPUs given in physical bitmap \\p set."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_thread_t is \\p pthread_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note ::HWLOC_CPUBIND_PROCESS can not be used in \\p flags."]
    pub fn hwloc_set_thread_cpubind(
        topology: hwloc_topology_t,
        thread: pthread_t,
        set: hwloc_const_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the current physical binding of thread \\p tid."]
    #[doc = ""]
    #[doc = " The CPU-set \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the list of PUs which the thread"]
    #[doc = " was last bound to."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_thread_t is \\p pthread_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note ::HWLOC_CPUBIND_PROCESS can not be used in \\p flags."]
    pub fn hwloc_get_thread_cpubind(
        topology: hwloc_topology_t,
        thread: pthread_t,
        set: hwloc_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the last physical CPU where the current process or thread ran."]
    #[doc = ""]
    #[doc = " The CPU-set \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the list of PUs which the process or"]
    #[doc = " thread (according to \\e flags) last ran on."]
    #[doc = ""]
    #[doc = " The operating system may move some tasks from one processor"]
    #[doc = " to another at any time according to their binding,"]
    #[doc = " so this function may return something that is already"]
    #[doc = " outdated."]
    #[doc = ""]
    #[doc = " \\p flags can include either ::HWLOC_CPUBIND_PROCESS or ::HWLOC_CPUBIND_THREAD to"]
    #[doc = " specify whether the query should be for the whole process (union of all CPUs"]
    #[doc = " on which all threads are running), or only the current thread. If the"]
    #[doc = " process is single-threaded, flags can be set to zero to let hwloc use"]
    #[doc = " whichever method is available on the underlying OS."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_get_last_cpu_location(
        topology: hwloc_topology_t,
        set: hwloc_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the last physical CPU where a process ran."]
    #[doc = ""]
    #[doc = " The CPU-set \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the list of PUs which the process"]
    #[doc = " last ran on."]
    #[doc = ""]
    #[doc = " The operating system may move some tasks from one processor"]
    #[doc = " to another at any time according to their binding,"]
    #[doc = " so this function may return something that is already"]
    #[doc = " outdated."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note As a special case on Linux, if a tid (thread ID) is supplied"]
    #[doc = " instead of a pid (process ID) and ::HWLOC_CPUBIND_THREAD is passed in flags,"]
    #[doc = " the last CPU location of that specific thread is returned."]
    #[doc = ""]
    #[doc = " \\note On non-Linux systems, ::HWLOC_CPUBIND_THREAD can not be used in \\p flags."]
    pub fn hwloc_get_proc_last_cpu_location(
        topology: hwloc_topology_t,
        pid: pid_t,
        set: hwloc_cpuset_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Reset the memory allocation policy to the system default."]
#[doc = " Depending on the operating system, this may correspond to"]
#[doc = " ::HWLOC_MEMBIND_FIRSTTOUCH (Linux, FreeBSD),"]
#[doc = " or ::HWLOC_MEMBIND_BIND (AIX, HP-UX, Solaris, Windows)."]
#[doc = " This policy is never returned by get membind functions."]
#[doc = " The nodeset argument is ignored."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_DEFAULT: hwloc_membind_policy_t = 0;
#[doc = " \\brief Allocate each memory page individually on the local NUMA"]
#[doc = " node of the thread that touches it."]
#[doc = ""]
#[doc = " The given nodeset should usually be hwloc_topology_get_topology_nodeset()"]
#[doc = " so that the touching thread may run and allocate on any node in the system."]
#[doc = ""]
#[doc = " On AIX, if the nodeset is smaller, pages are allocated locally (if the local"]
#[doc = " node is in the nodeset) or from a random non-local node (otherwise)."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_FIRSTTOUCH: hwloc_membind_policy_t = 1;
#[doc = " \\brief Allocate memory on the specified nodes."]
#[doc = ""]
#[doc = " The actual behavior may slightly vary between operating systems,"]
#[doc = " especially when (some of) the requested nodes are full."]
#[doc = " On Linux, by default, the MPOL_PREFERRED_MANY (or MPOL_PREFERRED) policy"]
#[doc = " is used. However, if the hwloc strict flag is also given, the Linux"]
#[doc = " MPOL_BIND policy is rather used."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_BIND: hwloc_membind_policy_t = 2;
#[doc = " \\brief Allocate memory on the given nodes in an interleaved"]
#[doc = " / round-robin manner.  The precise layout of the memory across"]
#[doc = " multiple NUMA nodes is OS/system specific. Interleaving can be"]
#[doc = " useful when threads distributed across the specified NUMA nodes"]
#[doc = " will all be accessing the whole memory range concurrently, since"]
#[doc = " the interleave will then balance the memory references."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_INTERLEAVE: hwloc_membind_policy_t = 3;
#[doc = " \\brief For each page bound with this policy, by next time"]
#[doc = " it is touched (and next time only), it is moved from its current"]
#[doc = " location to the local NUMA node of the thread where the memory"]
#[doc = " reference occurred (if it needs to be moved at all)."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_NEXTTOUCH: hwloc_membind_policy_t = 4;
#[doc = " \\brief Returned by get_membind() functions when multiple"]
#[doc = " threads or parts of a memory area have differing memory binding"]
#[doc = " policies."]
#[doc = " Also returned when binding is unknown because binding hooks are empty"]
#[doc = " when the topology is loaded from XML without HWLOC_THISSYSTEM=1, etc."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_policy_t_HWLOC_MEMBIND_MIXED: hwloc_membind_policy_t = -1;
#[doc = " \\brief Memory binding policy."]
#[doc = ""]
#[doc = " These constants can be used to choose the binding policy.  Only one policy can"]
#[doc = " be used at a time (i.e., the values cannot be OR'ed together)."]
#[doc = ""]
#[doc = " Not all systems support all kinds of binding."]
#[doc = " hwloc_topology_get_support() may be used to query about the actual memory"]
#[doc = " binding policy support in the currently used operating system."]
#[doc = " See the \"Detailed Description\" section of \\ref hwlocality_membinding"]
#[doc = " for a description of errors that can occur."]
pub type hwloc_membind_policy_t = ::std::os::raw::c_int;
#[doc = " \\brief Set policy for all threads of the specified (possibly"]
#[doc = " multithreaded) process.  This flag is mutually exclusive with"]
#[doc = " ::HWLOC_MEMBIND_THREAD."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_PROCESS: hwloc_membind_flags_t = 1;
#[doc = " \\brief Set policy for a specific thread of the current process."]
#[doc = " This flag is mutually exclusive with ::HWLOC_MEMBIND_PROCESS."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_THREAD: hwloc_membind_flags_t = 2;
#[doc = " Request strict binding from the OS.  The function will fail if"]
#[doc = " the binding can not be guaranteed / completely enforced."]
#[doc = ""]
#[doc = " This flag has slightly different meanings depending on which"]
#[doc = " function it is used with."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_STRICT: hwloc_membind_flags_t = 4;
#[doc = " \\brief Migrate existing allocated memory.  If the memory cannot"]
#[doc = " be migrated and the ::HWLOC_MEMBIND_STRICT flag is passed, an error"]
#[doc = " will be returned."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_MIGRATE: hwloc_membind_flags_t = 8;
#[doc = " \\brief Avoid any effect on CPU binding."]
#[doc = ""]
#[doc = " On some operating systems, some underlying memory binding"]
#[doc = " functions also bind the application to the corresponding CPU(s)."]
#[doc = " Using this flag will cause hwloc to avoid using OS functions that"]
#[doc = " could potentially affect CPU bindings.  Note, however, that using"]
#[doc = " NOCPUBIND may reduce hwloc's overall memory binding"]
#[doc = " support. Specifically: some of hwloc's memory binding functions"]
#[doc = " may fail with errno set to \\c ENOSYS when used with NOCPUBIND."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_NOCPUBIND: hwloc_membind_flags_t = 16;
#[doc = " \\brief Consider the bitmap argument as a nodeset."]
#[doc = ""]
#[doc = " The bitmap argument is considered a nodeset if this flag is given,"]
#[doc = " or a cpuset otherwise by default."]
#[doc = ""]
#[doc = " Memory binding by CPU set cannot work for CPU-less NUMA memory nodes."]
#[doc = " Binding by nodeset should therefore be preferred whenever possible."]
#[doc = " \\hideinitializer"]
pub const hwloc_membind_flags_t_HWLOC_MEMBIND_BYNODESET: hwloc_membind_flags_t = 32;
#[doc = " \\brief Memory binding flags."]
#[doc = ""]
#[doc = " These flags can be used to refine the binding policy."]
#[doc = " All flags can be logically OR'ed together with the exception of"]
#[doc = " ::HWLOC_MEMBIND_PROCESS and ::HWLOC_MEMBIND_THREAD;"]
#[doc = " these two flags are mutually exclusive."]
#[doc = ""]
#[doc = " Not all systems support all kinds of binding."]
#[doc = " hwloc_topology_get_support() may be used to query about the actual memory"]
#[doc = " binding support in the currently used operating system."]
#[doc = " See the \"Detailed Description\" section of \\ref hwlocality_membinding"]
#[doc = " for a description of errors that can occur."]
pub type hwloc_membind_flags_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Set the default memory binding policy of the current"]
    #[doc = " process or thread to prefer the NUMA node(s) specified by \\p set"]
    #[doc = ""]
    #[doc = " If neither ::HWLOC_MEMBIND_PROCESS nor ::HWLOC_MEMBIND_THREAD is"]
    #[doc = " specified, the current process is assumed to be single-threaded."]
    #[doc = " This is the most portable form as it permits hwloc to use either"]
    #[doc = " process-based OS functions or thread-based OS functions, depending"]
    #[doc = " on which are available."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c ENOSYS if the action is not supported."]
    #[doc = " \\return -1 with errno set to \\c EXDEV if the binding cannot be enforced."]
    pub fn hwloc_set_membind(
        topology: hwloc_topology_t,
        set: hwloc_const_bitmap_t,
        policy: hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Query the default memory binding policy and physical locality of the"]
    #[doc = " current process or thread."]
    #[doc = ""]
    #[doc = " The bitmap \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the process or thread memory binding."]
    #[doc = ""]
    #[doc = " This function has two output parameters: \\p set and \\p policy."]
    #[doc = " The values returned in these parameters depend on both the \\p flags"]
    #[doc = " passed in and the current memory binding policies and nodesets in"]
    #[doc = " the queried target."]
    #[doc = ""]
    #[doc = " Passing the ::HWLOC_MEMBIND_PROCESS flag specifies that the query"]
    #[doc = " target is the current policies and nodesets for all the threads in"]
    #[doc = " the current process.  Passing ::HWLOC_MEMBIND_THREAD specifies that"]
    #[doc = " the query target is the current policy and nodeset for only the"]
    #[doc = " thread invoking this function."]
    #[doc = ""]
    #[doc = " If neither of these flags are passed (which is the most portable"]
    #[doc = " method), the process is assumed to be single threaded.  This allows"]
    #[doc = " hwloc to use either process-based OS functions or thread-based OS"]
    #[doc = " functions, depending on which are available."]
    #[doc = ""]
    #[doc = " ::HWLOC_MEMBIND_STRICT is only meaningful when ::HWLOC_MEMBIND_PROCESS"]
    #[doc = " is also specified.  In this case, hwloc will check the default"]
    #[doc = " memory policies and nodesets for all threads in the process.  If"]
    #[doc = " they are not identical, -1 is returned and errno is set to \\c EXDEV."]
    #[doc = " If they are identical, the values are returned in \\p set and \\p"]
    #[doc = " policy."]
    #[doc = ""]
    #[doc = " Otherwise, if ::HWLOC_MEMBIND_PROCESS is specified (and"]
    #[doc = " ::HWLOC_MEMBIND_STRICT is \\em not specified), the default set"]
    #[doc = " from each thread is logically OR'ed together."]
    #[doc = " If all threads' default policies are the same, \\p policy is set to"]
    #[doc = " that policy.  If they are different, \\p policy is set to"]
    #[doc = " ::HWLOC_MEMBIND_MIXED."]
    #[doc = ""]
    #[doc = " In the ::HWLOC_MEMBIND_THREAD case (or when neither"]
    #[doc = " ::HWLOC_MEMBIND_PROCESS or ::HWLOC_MEMBIND_THREAD is specified), there"]
    #[doc = " is only one set and policy; they are returned in \\p set and"]
    #[doc = " \\p policy, respectively."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " If any other flags are specified, -1 is returned and errno is set"]
    #[doc = " to \\c EINVAL."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_get_membind(
        topology: hwloc_topology_t,
        set: hwloc_bitmap_t,
        policy: *mut hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the default memory binding policy of the specified"]
    #[doc = " process to prefer the NUMA node(s) specified by \\p set"]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c ENOSYS if the action is not supported."]
    #[doc = " \\return -1 with errno set to \\c EXDEV if the binding cannot be enforced."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    pub fn hwloc_set_proc_membind(
        topology: hwloc_topology_t,
        pid: pid_t,
        set: hwloc_const_bitmap_t,
        policy: hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Query the default memory binding policy and physical locality of the"]
    #[doc = " specified process."]
    #[doc = ""]
    #[doc = " The bitmap \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the process memory binding."]
    #[doc = ""]
    #[doc = " This function has two output parameters: \\p set and \\p policy."]
    #[doc = " The values returned in these parameters depend on both the \\p flags"]
    #[doc = " passed in and the current memory binding policies and nodesets in"]
    #[doc = " the queried target."]
    #[doc = ""]
    #[doc = " Passing the ::HWLOC_MEMBIND_PROCESS flag specifies that the query"]
    #[doc = " target is the current policies and nodesets for all the threads in"]
    #[doc = " the specified process.  If ::HWLOC_MEMBIND_PROCESS is not specified"]
    #[doc = " (which is the most portable method), the process is assumed to be"]
    #[doc = " single threaded.  This allows hwloc to use either process-based OS"]
    #[doc = " functions or thread-based OS functions, depending on which are"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " Note that it does not make sense to pass ::HWLOC_MEMBIND_THREAD to"]
    #[doc = " this function."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_STRICT is specified, hwloc will check the default"]
    #[doc = " memory policies and nodesets for all threads in the specified"]
    #[doc = " process.  If they are not identical, -1 is returned and errno is"]
    #[doc = " set to \\c EXDEV.  If they are identical, the values are returned in \\p"]
    #[doc = " set and \\p policy."]
    #[doc = ""]
    #[doc = " Otherwise, \\p set is set to the logical OR of all threads'"]
    #[doc = " default set.  If all threads' default policies"]
    #[doc = " are the same, \\p policy is set to that policy.  If they are"]
    #[doc = " different, \\p policy is set to ::HWLOC_MEMBIND_MIXED."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " If any other flags are specified, -1 is returned and errno is set"]
    #[doc = " to \\c EINVAL."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    pub fn hwloc_get_proc_membind(
        topology: hwloc_topology_t,
        pid: pid_t,
        set: hwloc_bitmap_t,
        policy: *mut hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Bind the already-allocated memory identified by (addr, len)"]
    #[doc = " to the NUMA node(s) specified by \\p set."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " \\return 0 on success or if \\p len is 0."]
    #[doc = " \\return -1 with errno set to \\c ENOSYS if the action is not supported."]
    #[doc = " \\return -1 with errno set to \\c EXDEV if the binding cannot be enforced."]
    pub fn hwloc_set_area_membind(
        topology: hwloc_topology_t,
        addr: *const ::std::os::raw::c_void,
        len: size_t,
        set: hwloc_const_bitmap_t,
        policy: hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Query the CPUs near the physical NUMA node(s) and binding policy of"]
    #[doc = " the memory identified by (\\p addr, \\p len )."]
    #[doc = ""]
    #[doc = " The bitmap \\p set (previously allocated by the caller)"]
    #[doc = " is filled with the memory area binding."]
    #[doc = ""]
    #[doc = " This function has two output parameters: \\p set and \\p policy."]
    #[doc = " The values returned in these parameters depend on both the \\p flags"]
    #[doc = " passed in and the memory binding policies and nodesets of the pages"]
    #[doc = " in the address range."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_STRICT is specified, the target pages are first"]
    #[doc = " checked to see if they all have the same memory binding policy and"]
    #[doc = " nodeset.  If they do not, -1 is returned and errno is set to \\c EXDEV."]
    #[doc = " If they are identical across all pages, the set and policy are"]
    #[doc = " returned in \\p set and \\p policy, respectively."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_STRICT is not specified, the union of all NUMA"]
    #[doc = " node(s) containing pages in the address range is calculated."]
    #[doc = " If all pages in the target have the same policy, it is returned in"]
    #[doc = " \\p policy.  Otherwise, \\p policy is set to ::HWLOC_MEMBIND_MIXED."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " If any other flags are specified, -1 is returned and errno is set"]
    #[doc = " to \\c EINVAL."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c EINVAL if \\p len is 0."]
    pub fn hwloc_get_area_membind(
        topology: hwloc_topology_t,
        addr: *const ::std::os::raw::c_void,
        len: size_t,
        set: hwloc_bitmap_t,
        policy: *mut hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the NUMA nodes where memory identified by (\\p addr, \\p len ) is physically allocated."]
    #[doc = ""]
    #[doc = " The bitmap \\p set (previously allocated by the caller)"]
    #[doc = " is filled according to the NUMA nodes where the memory area pages"]
    #[doc = " are physically allocated. If no page is actually allocated yet,"]
    #[doc = " \\p set may be empty."]
    #[doc = ""]
    #[doc = " If pages spread to multiple nodes, it is not specified whether they spread"]
    #[doc = " equitably, or whether most of them are on a single node, etc."]
    #[doc = ""]
    #[doc = " The operating system may move memory pages from one processor"]
    #[doc = " to another at any time according to their binding,"]
    #[doc = " so this function may return something that is already"]
    #[doc = " outdated."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified in \\p flags, set is"]
    #[doc = " considered a nodeset. Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " If \\p len is 0, \\p set is emptied."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_get_area_memlocation(
        topology: hwloc_topology_t,
        addr: *const ::std::os::raw::c_void,
        len: size_t,
        set: hwloc_bitmap_t,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Allocate some memory"]
    #[doc = ""]
    #[doc = " This is equivalent to malloc(), except that it tries to allocate"]
    #[doc = " page-aligned memory from the OS."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated area, or \\c NULL on error."]
    #[doc = ""]
    #[doc = " \\note The allocated memory should be freed with hwloc_free()."]
    pub fn hwloc_alloc(topology: hwloc_topology_t, len: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Allocate some memory on NUMA memory nodes specified by \\p set"]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated area."]
    #[doc = " \\return NULL with errno set to \\c ENOSYS if the action is not supported"]
    #[doc = " and ::HWLOC_MEMBIND_STRICT is given."]
    #[doc = " \\return NULL with errno set to \\c EXDEV if the binding cannot be enforced"]
    #[doc = " and ::HWLOC_MEMBIND_STRICT is given."]
    #[doc = " \\return NULL with errno set to \\c ENOMEM if the memory allocation failed"]
    #[doc = " even before trying to bind."]
    #[doc = ""]
    #[doc = " If ::HWLOC_MEMBIND_BYNODESET is specified, set is considered a nodeset."]
    #[doc = " Otherwise it's a cpuset."]
    #[doc = ""]
    #[doc = " \\note The allocated memory should be freed with hwloc_free()."]
    pub fn hwloc_alloc_membind(
        topology: hwloc_topology_t,
        len: size_t,
        set: hwloc_const_bitmap_t,
        policy: hwloc_membind_policy_t,
        flags: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief Free memory that was previously allocated by hwloc_alloc()"]
    #[doc = " or hwloc_alloc_membind()."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_free(
        topology: hwloc_topology_t,
        addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Change which process the topology is viewed from."]
    #[doc = ""]
    #[doc = " On some systems, processes may have different views of the machine, for"]
    #[doc = " instance the set of allowed CPUs. By default, hwloc exposes the view from"]
    #[doc = " the current process. Calling hwloc_topology_set_pid() permits to make it"]
    #[doc = " expose the topology of the machine from the point of view of another"]
    #[doc = " process."]
    #[doc = ""]
    #[doc = " \\note \\p hwloc_pid_t is \\p pid_t on Unix platforms,"]
    #[doc = " and \\p HANDLE on native Windows platforms."]
    #[doc = ""]
    #[doc = " \\note -1 is returned and errno is set to \\c ENOSYS on platforms that do not"]
    #[doc = " support this feature."]
    #[doc = ""]
    #[doc = " \\note The PID will not actually be used until hwloc_topology_load()."]
    #[doc = " If the corresponding process exits in the meantime, hwloc will ignore the PID."]
    #[doc = " If another process reuses the PID, the view of that process will be used."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_topology_set_pid(topology: hwloc_topology_t, pid: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Enable synthetic topology."]
    #[doc = ""]
    #[doc = " Gather topology information from the given \\p description,"]
    #[doc = " a space-separated string of <type:number> describing"]
    #[doc = " the object type and arity at each level."]
    #[doc = " All types may be omitted (space-separated string of numbers) so that"]
    #[doc = " hwloc chooses all types according to usual topologies."]
    #[doc = " See also the \\ref synthetic."]
    #[doc = ""]
    #[doc = " Setting the environment variable HWLOC_SYNTHETIC"]
    #[doc = " may also result in this behavior."]
    #[doc = ""]
    #[doc = " If \\p description was properly parsed and describes a valid topology"]
    #[doc = " configuration, this function returns 0."]
    #[doc = " Otherwise -1 is returned and errno is set to \\c EINVAL."]
    #[doc = ""]
    #[doc = " Note that this function does not actually load topology"]
    #[doc = " information; it just tells hwloc where to load it from.  You'll"]
    #[doc = " still need to invoke hwloc_topology_load() to actually load the"]
    #[doc = " topology information."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c EINVAL if the description was invalid."]
    #[doc = ""]
    #[doc = " \\note For convenience, this backend provides empty binding hooks which just"]
    #[doc = " return success."]
    #[doc = ""]
    #[doc = " \\note On success, the synthetic component replaces the previously enabled"]
    #[doc = " component (if any), but the topology is not actually modified until"]
    #[doc = " hwloc_topology_load()."]
    pub fn hwloc_topology_set_synthetic(
        topology: hwloc_topology_t,
        description: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Enable XML-file based topology."]
    #[doc = ""]
    #[doc = " Gather topology information from the XML file given at \\p xmlpath."]
    #[doc = " Setting the environment variable HWLOC_XMLFILE may also result in this behavior."]
    #[doc = " This file may have been generated earlier with hwloc_topology_export_xml() in hwloc/export.h,"]
    #[doc = " or lstopo file.xml."]
    #[doc = ""]
    #[doc = " Note that this function does not actually load topology"]
    #[doc = " information; it just tells hwloc where to load it from.  You'll"]
    #[doc = " still need to invoke hwloc_topology_load() to actually load the"]
    #[doc = " topology information."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c EINVAL on failure to read the XML file."]
    #[doc = ""]
    #[doc = " \\note See also hwloc_topology_set_userdata_import_callback()"]
    #[doc = " for importing application-specific object userdata."]
    #[doc = ""]
    #[doc = " \\note For convenience, this backend provides empty binding hooks which just"]
    #[doc = " return success.  To have hwloc still actually call OS-specific hooks, the"]
    #[doc = " ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM has to be set to assert that the loaded"]
    #[doc = " file is really the underlying system."]
    #[doc = ""]
    #[doc = " \\note On success, the XML component replaces the previously enabled"]
    #[doc = " component (if any), but the topology is not actually modified until"]
    #[doc = " hwloc_topology_load()."]
    #[doc = ""]
    #[doc = " \\note If an invalid XML input file is given, the error may be reported"]
    #[doc = " either here or later by hwloc_topology_load() depending on the XML library"]
    #[doc = " used by hwloc."]
    pub fn hwloc_topology_set_xml(
        topology: hwloc_topology_t,
        xmlpath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Enable XML based topology using a memory buffer (instead of"]
    #[doc = " a file, as with hwloc_topology_set_xml())."]
    #[doc = ""]
    #[doc = " Gather topology information from the XML memory buffer given at"]
    #[doc = " \\p buffer and of length \\p size (including an ending \\0)."]
    #[doc = " This buffer may have been filled earlier with"]
    #[doc = " hwloc_topology_export_xmlbuffer() in hwloc/export.h."]
    #[doc = ""]
    #[doc = " Note that this function does not actually load topology"]
    #[doc = " information; it just tells hwloc where to load it from.  You'll"]
    #[doc = " still need to invoke hwloc_topology_load() to actually load the"]
    #[doc = " topology information."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c EINVAL on failure to read the XML buffer."]
    #[doc = ""]
    #[doc = " \\note See also hwloc_topology_set_userdata_import_callback()"]
    #[doc = " for importing application-specific object userdata."]
    #[doc = ""]
    #[doc = " \\note For convenience, this backend provides empty binding hooks which just"]
    #[doc = " return success.  To have hwloc still actually call OS-specific hooks, the"]
    #[doc = " ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM has to be set to assert that the loaded"]
    #[doc = " file is really the underlying system."]
    #[doc = ""]
    #[doc = " \\note On success, the XML component replaces the previously enabled"]
    #[doc = " component (if any), but the topology is not actually modified until"]
    #[doc = " hwloc_topology_load()."]
    #[doc = ""]
    #[doc = " \\note If an invalid XML input file is given, the error may be reported"]
    #[doc = " either here or later by hwloc_topology_load() depending on the XML library"]
    #[doc = " used by hwloc."]
    pub fn hwloc_topology_set_xmlbuffer(
        topology: hwloc_topology_t,
        buffer: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Blacklist the target component from being used."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_components_flag_e_HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST:
    hwloc_topology_components_flag_e = 1;
#[doc = " \\brief Flags to be passed to hwloc_topology_set_components()"]
pub type hwloc_topology_components_flag_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Prevent a discovery component from being used for a topology."]
    #[doc = ""]
    #[doc = " \\p name is the name of the discovery component that should not be used"]
    #[doc = " when loading topology \\p topology. The name is a string such as \"cuda\"."]
    #[doc = ""]
    #[doc = " For components with multiple phases, it may also be suffixed with the name"]
    #[doc = " of a phase, for instance \"linux:io\"."]
    #[doc = ""]
    #[doc = " \\p flags should be ::HWLOC_TOPOLOGY_COMPONENTS_FLAG_BLACKLIST."]
    #[doc = ""]
    #[doc = " This may be used to avoid expensive parts of the discovery process."]
    #[doc = " For instance, CUDA-specific discovery may be expensive and unneeded"]
    #[doc = " while generic I/O discovery could still be useful."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 on error, for instance if flags are invalid."]
    pub fn hwloc_topology_set_components(
        topology: hwloc_topology_t,
        flags: ::std::os::raw::c_ulong,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Detect the whole system, ignore reservations, include disallowed objects."]
#[doc = ""]
#[doc = " Gather all online resources, even if some were disabled by the administrator."]
#[doc = " For instance, ignore Linux Cgroup/Cpusets and gather all processors and memory nodes."]
#[doc = " However offline PUs and NUMA nodes are still ignored."]
#[doc = ""]
#[doc = " When this flag is not set, PUs and NUMA nodes that are disallowed are not added to the topology."]
#[doc = " Parent objects (package, core, cache, etc.) are added only if some of their children are allowed."]
#[doc = " All existing PUs and NUMA nodes in the topology are allowed."]
#[doc = " hwloc_topology_get_allowed_cpuset() and hwloc_topology_get_allowed_nodeset()"]
#[doc = " are equal to the root object cpuset and nodeset."]
#[doc = ""]
#[doc = " When this flag is set, the actual sets of allowed PUs and NUMA nodes are given"]
#[doc = " by hwloc_topology_get_allowed_cpuset() and hwloc_topology_get_allowed_nodeset()."]
#[doc = " They may be smaller than the root object cpuset and nodeset."]
#[doc = ""]
#[doc = " If the current topology is exported to XML and reimported later, this flag"]
#[doc = " should be set again in the reimported topology so that disallowed resources"]
#[doc = " are reimported as well."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED: hwloc_topology_flags_e = 1;
#[doc = " \\brief Assume that the selected backend provides the topology for the"]
#[doc = " system on which we are running."]
#[doc = ""]
#[doc = " This forces hwloc_topology_is_thissystem() to return 1, i.e. makes hwloc assume that"]
#[doc = " the selected backend provides the topology for the system on which we are running,"]
#[doc = " even if it is not the OS-specific backend but the XML backend for instance."]
#[doc = " This means making the binding functions actually call the OS-specific"]
#[doc = " system calls and really do binding, while the XML backend would otherwise"]
#[doc = " provide empty hooks just returning success."]
#[doc = ""]
#[doc = " Setting the environment variable HWLOC_THISSYSTEM may also result in the"]
#[doc = " same behavior."]
#[doc = ""]
#[doc = " This can be used for efficiency reasons to first detect the topology once,"]
#[doc = " save it to an XML file, and quickly reload it later through the XML"]
#[doc = " backend, but still having binding functions actually do bind."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM: hwloc_topology_flags_e = 2;
#[doc = " \\brief Get the set of allowed resources from the local operating system even if the topology was loaded from XML or synthetic description."]
#[doc = ""]
#[doc = " If the topology was loaded from XML or from a synthetic string,"]
#[doc = " restrict it by applying the current process restrictions such as"]
#[doc = " Linux Cgroup/Cpuset."]
#[doc = ""]
#[doc = " This is useful when the topology is not loaded directly from"]
#[doc = " the local machine (e.g. for performance reason) and it comes"]
#[doc = " with all resources, while the running process is restricted"]
#[doc = " to only parts of the machine."]
#[doc = ""]
#[doc = " This flag is ignored unless ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM is"]
#[doc = " also set since the loaded topology must match the underlying machine"]
#[doc = " where restrictions will be gathered from."]
#[doc = ""]
#[doc = " Setting the environment variable HWLOC_THISSYSTEM_ALLOWED_RESOURCES"]
#[doc = " would result in the same behavior."]
#[doc = " \\hideinitializer"]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_THISSYSTEM_ALLOWED_RESOURCES:
    hwloc_topology_flags_e = 4;
#[doc = " \\brief Import support from the imported topology."]
#[doc = ""]
#[doc = " When importing a XML topology from a remote machine, binding is"]
#[doc = " disabled by default (see ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)."]
#[doc = " This disabling is also marked by putting zeroes in the corresponding"]
#[doc = " supported feature bits reported by hwloc_topology_get_support()."]
#[doc = ""]
#[doc = " The flag ::HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT actually imports"]
#[doc = " support bits from the remote machine. It also sets the flag"]
#[doc = " \\p imported_support in the struct hwloc_topology_misc_support array."]
#[doc = " If the imported XML did not contain any support information"]
#[doc = " (exporter hwloc is too old), this flag is not set."]
#[doc = ""]
#[doc = " Note that these supported features are only relevant for the hwloc"]
#[doc = " installation that actually exported the XML topology"]
#[doc = " (it may vary with the operating system, or with how hwloc was compiled)."]
#[doc = ""]
#[doc = " Note that setting this flag however does not enable binding for the"]
#[doc = " locally imported hwloc topology, it only reports what the remote"]
#[doc = " hwloc and machine support."]
#[doc = ""]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT: hwloc_topology_flags_e = 8;
#[doc = " \\brief Do not consider resources outside of the process CPU binding."]
#[doc = ""]
#[doc = " If the binding of the process is limited to a subset of cores,"]
#[doc = " ignore the other cores during discovery."]
#[doc = ""]
#[doc = " The resulting topology is identical to what a call to hwloc_topology_restrict()"]
#[doc = " would generate, but this flag also prevents hwloc from ever touching other"]
#[doc = " resources during the discovery."]
#[doc = ""]
#[doc = " This flag especially tells the x86 backend to never temporarily"]
#[doc = " rebind a thread on any excluded core. This is useful on Windows"]
#[doc = " because such temporary rebinding can change the process binding."]
#[doc = " Another use-case is to avoid cores that would not be able to"]
#[doc = " perform the hwloc discovery anytime soon because they are busy"]
#[doc = " executing some high-priority real-time tasks."]
#[doc = ""]
#[doc = " If process CPU binding is not supported,"]
#[doc = " the thread CPU binding is considered instead if supported,"]
#[doc = " or the flag is ignored."]
#[doc = ""]
#[doc = " This flag requires ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM as well"]
#[doc = " since binding support is required."]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING:
    hwloc_topology_flags_e = 16;
#[doc = " \\brief Do not consider resources outside of the process memory binding."]
#[doc = ""]
#[doc = " If the binding of the process is limited to a subset of NUMA nodes,"]
#[doc = " ignore the other NUMA nodes during discovery."]
#[doc = ""]
#[doc = " The resulting topology is identical to what a call to hwloc_topology_restrict()"]
#[doc = " would generate, but this flag also prevents hwloc from ever touching other"]
#[doc = " resources during the discovery."]
#[doc = ""]
#[doc = " This flag is meant to be used together with"]
#[doc = " ::HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING when both cores"]
#[doc = " and NUMA nodes should be ignored outside of the process binding."]
#[doc = ""]
#[doc = " If process memory binding is not supported,"]
#[doc = " the thread memory binding is considered instead if supported,"]
#[doc = " or the flag is ignored."]
#[doc = ""]
#[doc = " This flag requires ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM as well"]
#[doc = " since binding support is required."]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_MEMBINDING:
    hwloc_topology_flags_e = 32;
#[doc = " \\brief Do not ever modify the process or thread binding during discovery."]
#[doc = ""]
#[doc = " This flag disables all hwloc discovery steps that require a change of"]
#[doc = " the process or thread binding. This currently only affects the x86"]
#[doc = " backend which gets entirely disabled."]
#[doc = ""]
#[doc = " This is useful when hwloc_topology_load() is called while the"]
#[doc = " application also creates additional threads or modifies the binding."]
#[doc = ""]
#[doc = " This flag is also a strict way to make sure the process binding will"]
#[doc = " not change to due thread binding changes on Windows"]
#[doc = " (see ::HWLOC_TOPOLOGY_FLAG_RESTRICT_TO_CPUBINDING)."]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_DONT_CHANGE_BINDING: hwloc_topology_flags_e =
    64;
#[doc = " \\brief Ignore distances."]
#[doc = ""]
#[doc = " Ignore distance information from the operating systems (and from XML)"]
#[doc = " and hence do not use distances for grouping."]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_NO_DISTANCES: hwloc_topology_flags_e = 128;
#[doc = " \\brief Ignore memory attributes and tiers."]
#[doc = ""]
#[doc = " Ignore memory attribues from the operating systems (and from XML)"]
#[doc = " Hence also do not try to build memory tiers."]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_NO_MEMATTRS: hwloc_topology_flags_e = 256;
#[doc = " \\brief Ignore CPU Kinds."]
#[doc = ""]
#[doc = " Ignore CPU kind information from the operating systems (and from XML)."]
pub const hwloc_topology_flags_e_HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS: hwloc_topology_flags_e = 512;
#[doc = " \\brief Flags to be set onto a topology context before load."]
#[doc = ""]
#[doc = " Flags should be given to hwloc_topology_set_flags()."]
#[doc = " They may also be returned by hwloc_topology_get_flags()."]
pub type hwloc_topology_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Set OR'ed flags to non-yet-loaded topology."]
    #[doc = ""]
    #[doc = " Set a OR'ed set of ::hwloc_topology_flags_e onto a topology that was not yet loaded."]
    #[doc = ""]
    #[doc = " If this function is called multiple times, the last invocation will erase"]
    #[doc = " and replace the set of flags that was previously set."]
    #[doc = ""]
    #[doc = " By default, no flags are set (\\c 0)."]
    #[doc = ""]
    #[doc = " The flags set in a topology may be retrieved with hwloc_topology_get_flags()."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 on error, for instance if flags are invalid."]
    pub fn hwloc_topology_set_flags(
        topology: hwloc_topology_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get OR'ed flags of a topology."]
    #[doc = ""]
    #[doc = " Get the OR'ed set of ::hwloc_topology_flags_e of a topology."]
    #[doc = ""]
    #[doc = " If hwloc_topology_set_flags() was not called earlier,"]
    #[doc = " no flags are set (\\c 0 is returned)."]
    #[doc = ""]
    #[doc = " \\return the flags previously set with hwloc_topology_set_flags()."]
    #[doc = ""]
    #[doc = " \\note This function may also be called after hwloc_topology_load()."]
    pub fn hwloc_topology_get_flags(topology: hwloc_topology_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " \\brief Does the topology context come from this system?"]
    #[doc = ""]
    #[doc = " \\return 1 if this topology context was built using the system"]
    #[doc = " running this program."]
    #[doc = " \\return 0 instead (for instance if using another file-system root,"]
    #[doc = " a XML topology file, or a synthetic topology)."]
    #[doc = ""]
    #[doc = " \\note This function may also be called after hwloc_topology_load()."]
    pub fn hwloc_topology_is_thissystem(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Flags describing actual discovery support for this topology."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_discovery_support {
    #[doc = " \\brief Detecting the number of PU objects is supported."]
    pub pu: ::std::os::raw::c_uchar,
    #[doc = " \\brief Detecting the number of NUMA nodes is supported."]
    pub numa: ::std::os::raw::c_uchar,
    #[doc = " \\brief Detecting the amount of memory in NUMA nodes is supported."]
    pub numa_memory: ::std::os::raw::c_uchar,
    #[doc = " \\brief Detecting and identifying PU objects that are not available to the current process is supported."]
    pub disallowed_pu: ::std::os::raw::c_uchar,
    #[doc = " \\brief Detecting and identifying NUMA nodes that are not available to the current process is supported."]
    pub disallowed_numa: ::std::os::raw::c_uchar,
    #[doc = " \\brief Detecting the efficiency of CPU kinds is supported, see \\ref hwlocality_cpukinds."]
    pub cpukind_efficiency: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_topology_discovery_support() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_discovery_support>(),
        6usize,
        concat!("Size of: ", stringify!(hwloc_topology_discovery_support))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_discovery_support>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_discovery_support)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).pu as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(pu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).numa as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(numa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).numa_memory as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(numa_memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).disallowed_pu as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(disallowed_pu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).disallowed_numa as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(disallowed_numa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_discovery_support>())).cpukind_efficiency
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_discovery_support),
            "::",
            stringify!(cpukind_efficiency)
        )
    );
}
#[doc = " \\brief Flags describing actual PU binding support for this topology."]
#[doc = ""]
#[doc = " A flag may be set even if the feature isn't supported in all cases"]
#[doc = " (e.g. binding to random sets of non-contiguous objects)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_cpubind_support {
    #[doc = " Binding the whole current process is supported."]
    pub set_thisproc_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of the whole current process is supported."]
    pub get_thisproc_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Binding a whole given process is supported."]
    pub set_proc_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of a whole given process is supported."]
    pub get_proc_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Binding the current thread only is supported."]
    pub set_thisthread_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of the current thread only is supported."]
    pub get_thisthread_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Binding a given thread only is supported."]
    pub set_thread_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of a given thread only is supported."]
    pub get_thread_cpubind: ::std::os::raw::c_uchar,
    #[doc = " Getting the last processors where the whole current process ran is supported"]
    pub get_thisproc_last_cpu_location: ::std::os::raw::c_uchar,
    #[doc = " Getting the last processors where a whole process ran is supported"]
    pub get_proc_last_cpu_location: ::std::os::raw::c_uchar,
    #[doc = " Getting the last processors where the current thread ran is supported"]
    pub get_thisthread_last_cpu_location: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_topology_cpubind_support() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_cpubind_support>(),
        11usize,
        concat!("Size of: ", stringify!(hwloc_topology_cpubind_support))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_cpubind_support>(),
        1usize,
        concat!("Alignment of ", stringify!(hwloc_topology_cpubind_support))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).set_thisproc_cpubind
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(set_thisproc_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).get_thisproc_cpubind
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_thisproc_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).set_proc_cpubind as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(set_proc_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).get_proc_cpubind as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_proc_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).set_thisthread_cpubind
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(set_thisthread_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).get_thisthread_cpubind
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_thisthread_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).set_thread_cpubind
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(set_thread_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).get_thread_cpubind
                as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_thread_cpubind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>()))
                .get_thisproc_last_cpu_location as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_thisproc_last_cpu_location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>())).get_proc_last_cpu_location
                as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_proc_last_cpu_location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_cpubind_support>()))
                .get_thisthread_last_cpu_location as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_cpubind_support),
            "::",
            stringify!(get_thisthread_last_cpu_location)
        )
    );
}
#[doc = " \\brief Flags describing actual memory binding support for this topology."]
#[doc = ""]
#[doc = " A flag may be set even if the feature isn't supported in all cases"]
#[doc = " (e.g. binding to random sets of non-contiguous objects)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_membind_support {
    #[doc = " Binding the whole current process is supported."]
    pub set_thisproc_membind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of the whole current process is supported."]
    pub get_thisproc_membind: ::std::os::raw::c_uchar,
    #[doc = " Binding a whole given process is supported."]
    pub set_proc_membind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of a whole given process is supported."]
    pub get_proc_membind: ::std::os::raw::c_uchar,
    #[doc = " Binding the current thread only is supported."]
    pub set_thisthread_membind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of the current thread only is supported."]
    pub get_thisthread_membind: ::std::os::raw::c_uchar,
    #[doc = " Binding a given memory area is supported."]
    pub set_area_membind: ::std::os::raw::c_uchar,
    #[doc = " Getting the binding of a given memory area is supported."]
    pub get_area_membind: ::std::os::raw::c_uchar,
    #[doc = " Allocating a bound memory area is supported."]
    pub alloc_membind: ::std::os::raw::c_uchar,
    #[doc = " First-touch policy is supported."]
    pub firsttouch_membind: ::std::os::raw::c_uchar,
    #[doc = " Bind policy is supported."]
    pub bind_membind: ::std::os::raw::c_uchar,
    #[doc = " Interleave policy is supported."]
    pub interleave_membind: ::std::os::raw::c_uchar,
    #[doc = " Next-touch migration policy is supported."]
    pub nexttouch_membind: ::std::os::raw::c_uchar,
    #[doc = " Migration flags is supported."]
    pub migrate_membind: ::std::os::raw::c_uchar,
    #[doc = " Getting the last NUMA nodes where a memory area was allocated is supported"]
    pub get_area_memlocation: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_topology_membind_support() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_membind_support>(),
        15usize,
        concat!("Size of: ", stringify!(hwloc_topology_membind_support))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_membind_support>(),
        1usize,
        concat!("Alignment of ", stringify!(hwloc_topology_membind_support))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).set_thisproc_membind
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(set_thisproc_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).get_thisproc_membind
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(get_thisproc_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).set_proc_membind as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(set_proc_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).get_proc_membind as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(get_proc_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).set_thisthread_membind
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(set_thisthread_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).get_thisthread_membind
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(get_thisthread_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).set_area_membind as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(set_area_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).get_area_membind as *const _
                as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(get_area_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).alloc_membind as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(alloc_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).firsttouch_membind
                as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(firsttouch_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).bind_membind as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(bind_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).interleave_membind
                as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(interleave_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).nexttouch_membind as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(nexttouch_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).migrate_membind as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(migrate_membind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_membind_support>())).get_area_memlocation
                as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_membind_support),
            "::",
            stringify!(get_area_memlocation)
        )
    );
}
#[doc = " \\brief Flags describing miscellaneous features."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_misc_support {
    #[doc = " Support was imported when importing another topology, see ::HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT."]
    pub imported_support: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_hwloc_topology_misc_support() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_misc_support>(),
        1usize,
        concat!("Size of: ", stringify!(hwloc_topology_misc_support))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_misc_support>(),
        1usize,
        concat!("Alignment of ", stringify!(hwloc_topology_misc_support))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_misc_support>())).imported_support as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_misc_support),
            "::",
            stringify!(imported_support)
        )
    );
}
#[doc = " \\brief Set of flags describing actual support for this topology."]
#[doc = ""]
#[doc = " This is retrieved with hwloc_topology_get_support() and will be valid until"]
#[doc = " the topology object is destroyed.  Note: the values are correct only after"]
#[doc = " discovery."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_support {
    pub discovery: *mut hwloc_topology_discovery_support,
    pub cpubind: *mut hwloc_topology_cpubind_support,
    pub membind: *mut hwloc_topology_membind_support,
    pub misc: *mut hwloc_topology_misc_support,
}
#[test]
fn bindgen_test_layout_hwloc_topology_support() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_support>(),
        32usize,
        concat!("Size of: ", stringify!(hwloc_topology_support))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_support>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_topology_support))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_support>())).discovery as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_support),
            "::",
            stringify!(discovery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_topology_support>())).cpubind as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_support),
            "::",
            stringify!(cpubind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_topology_support>())).membind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_support),
            "::",
            stringify!(membind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_topology_support>())).misc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_support),
            "::",
            stringify!(misc)
        )
    );
}
extern "C" {
    #[doc = " \\brief Retrieve the topology support."]
    #[doc = ""]
    #[doc = " Each flag indicates whether a feature is supported."]
    #[doc = " If set to 0, the feature is not supported."]
    #[doc = " If set to 1, the feature is supported, but the corresponding"]
    #[doc = " call may still fail in some corner cases."]
    #[doc = ""]
    #[doc = " These features are also listed by hwloc-info \\--support"]
    #[doc = ""]
    #[doc = " The reported features are what the current topology supports"]
    #[doc = " on the current machine. If the topology was exported to XML"]
    #[doc = " from another machine and later imported here, support still"]
    #[doc = " describes what is supported for this imported topology after"]
    #[doc = " import. By default, binding will be reported as unsupported"]
    #[doc = " in this case (see ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM)."]
    #[doc = ""]
    #[doc = " Topology flag ::HWLOC_TOPOLOGY_FLAG_IMPORT_SUPPORT may be used"]
    #[doc = " to report the supported features of the original remote machine"]
    #[doc = " instead. If it was successfully imported, \\p imported_support"]
    #[doc = " will be set in the struct hwloc_topology_misc_support array."]
    #[doc = ""]
    #[doc = " \\return A pointer to a support structure."]
    #[doc = ""]
    #[doc = " \\note The function cannot return \\c NULL."]
    #[doc = " \\note The returned pointer should not be freed, it belongs to the hwloc library."]
    #[doc = ""]
    #[doc = " \\note This function may be called before or after hwloc_topology_load()"]
    #[doc = " but the support structure only contains valid information after."]
    pub fn hwloc_topology_get_support(topology: hwloc_topology_t) -> *const hwloc_topology_support;
}
#[doc = " \\brief Keep all objects of this type."]
#[doc = ""]
#[doc = " Cannot be set for ::HWLOC_OBJ_GROUP (groups are designed only to add more structure to the topology)."]
#[doc = " \\hideinitializer"]
pub const hwloc_type_filter_e_HWLOC_TYPE_FILTER_KEEP_ALL: hwloc_type_filter_e = 0;
#[doc = " \\brief Ignore all objects of this type."]
#[doc = ""]
#[doc = " The bottom-level type ::HWLOC_OBJ_PU, the ::HWLOC_OBJ_NUMANODE type, and"]
#[doc = " the top-level type ::HWLOC_OBJ_MACHINE may not be ignored."]
#[doc = " \\hideinitializer"]
pub const hwloc_type_filter_e_HWLOC_TYPE_FILTER_KEEP_NONE: hwloc_type_filter_e = 1;
#[doc = " \\brief Only ignore objects if their entire level does not bring any structure."]
#[doc = ""]
#[doc = " Keep the entire level of objects if at least one of these objects adds"]
#[doc = " structure to the topology. An object brings structure when it has multiple"]
#[doc = " children and it is not the only child of its parent."]
#[doc = ""]
#[doc = " If all objects in the level are the only child of their parent, and if none"]
#[doc = " of them has multiple children, the entire level is removed."]
#[doc = ""]
#[doc = " Cannot be set for I/O and Misc objects since the topology structure does not matter there."]
#[doc = " \\hideinitializer"]
pub const hwloc_type_filter_e_HWLOC_TYPE_FILTER_KEEP_STRUCTURE: hwloc_type_filter_e = 2;
#[doc = " \\brief Only keep likely-important objects of the given type."]
#[doc = ""]
#[doc = " It is only useful for I/O object types."]
#[doc = " For ::HWLOC_OBJ_PCI_DEVICE and ::HWLOC_OBJ_OS_DEVICE, it means that only objects"]
#[doc = " of major/common kinds are kept (storage, network, OpenFabrics, CUDA,"]
#[doc = " OpenCL, RSMI, NVML, and displays)."]
#[doc = " Also, only OS devices directly attached on PCI (e.g. no USB) are reported."]
#[doc = " For ::HWLOC_OBJ_BRIDGE, it means that bridges are kept only if they have children."]
#[doc = ""]
#[doc = " This flag equivalent to ::HWLOC_TYPE_FILTER_KEEP_ALL for Normal, Memory and Misc types"]
#[doc = " since they are likely important."]
#[doc = " \\hideinitializer"]
pub const hwloc_type_filter_e_HWLOC_TYPE_FILTER_KEEP_IMPORTANT: hwloc_type_filter_e = 3;
#[doc = " \\brief Type filtering flags."]
#[doc = ""]
#[doc = " By default, most objects are kept (::HWLOC_TYPE_FILTER_KEEP_ALL)."]
#[doc = " Instruction caches, memory-side caches, I/O and Misc objects are ignored by default (::HWLOC_TYPE_FILTER_KEEP_NONE)."]
#[doc = " Group levels are ignored unless they bring structure (::HWLOC_TYPE_FILTER_KEEP_STRUCTURE)."]
#[doc = ""]
#[doc = " Note that group objects are also ignored individually (without the entire level)"]
#[doc = " when they do not bring structure."]
pub type hwloc_type_filter_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Set the filtering for the given object type."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_topology_set_type_filter(
        topology: hwloc_topology_t,
        type_: hwloc_obj_type_t,
        filter: hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the current filtering for the given object type."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_topology_get_type_filter(
        topology: hwloc_topology_t,
        type_: hwloc_obj_type_t,
        filter: *mut hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the filtering for all object types."]
    #[doc = ""]
    #[doc = " If some types do not support this filtering, they are silently ignored."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_topology_set_all_types_filter(
        topology: hwloc_topology_t,
        filter: hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the filtering for all CPU cache object types."]
    #[doc = ""]
    #[doc = " Memory-side caches are not involved since they are not CPU caches."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_topology_set_cache_types_filter(
        topology: hwloc_topology_t,
        filter: hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the filtering for all CPU instruction cache object types."]
    #[doc = ""]
    #[doc = " Memory-side caches are not involved since they are not CPU caches."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_topology_set_icache_types_filter(
        topology: hwloc_topology_t,
        filter: hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the filtering for all I/O object types."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    pub fn hwloc_topology_set_io_types_filter(
        topology: hwloc_topology_t,
        filter: hwloc_type_filter_e,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the topology-specific userdata pointer."]
    #[doc = ""]
    #[doc = " Each topology may store one application-given private data pointer."]
    #[doc = " It is initialized to \\c NULL."]
    #[doc = " hwloc will never modify it."]
    #[doc = ""]
    #[doc = " Use it as you wish, after hwloc_topology_init() and until hwloc_topolog_destroy()."]
    #[doc = ""]
    #[doc = " This pointer is not exported to XML."]
    pub fn hwloc_topology_set_userdata(
        topology: hwloc_topology_t,
        userdata: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Retrieve the topology-specific userdata pointer."]
    #[doc = ""]
    #[doc = " Retrieve the application-given private data pointer that was"]
    #[doc = " previously set with hwloc_topology_set_userdata()."]
    #[doc = ""]
    #[doc = " \\return A pointer to the private-data if any."]
    #[doc = " \\return \\c NULL if no private-data was previoulsy set."]
    pub fn hwloc_topology_get_userdata(topology: hwloc_topology_t) -> *mut ::std::os::raw::c_void;
}
#[doc = " \\brief Remove all objects that became CPU-less."]
#[doc = " By default, only objects that contain no PU and no memory are removed."]
#[doc = " This flag may not be used with ::HWLOC_RESTRICT_FLAG_BYNODESET."]
#[doc = " \\hideinitializer"]
pub const hwloc_restrict_flags_e_HWLOC_RESTRICT_FLAG_REMOVE_CPULESS: hwloc_restrict_flags_e = 1;
#[doc = " \\brief Restrict by nodeset instead of CPU set."]
#[doc = " Only keep objects whose nodeset is included or partially included in the given set."]
#[doc = " This flag may not be used with ::HWLOC_RESTRICT_FLAG_REMOVE_CPULESS."]
pub const hwloc_restrict_flags_e_HWLOC_RESTRICT_FLAG_BYNODESET: hwloc_restrict_flags_e = 8;
#[doc = " \\brief Remove all objects that became Memory-less."]
#[doc = " By default, only objects that contain no PU and no memory are removed."]
#[doc = " This flag may only be used with ::HWLOC_RESTRICT_FLAG_BYNODESET."]
#[doc = " \\hideinitializer"]
pub const hwloc_restrict_flags_e_HWLOC_RESTRICT_FLAG_REMOVE_MEMLESS: hwloc_restrict_flags_e = 16;
#[doc = " \\brief Move Misc objects to ancestors if their parents are removed during restriction."]
#[doc = " If this flag is not set, Misc objects are removed when their parents are removed."]
#[doc = " \\hideinitializer"]
pub const hwloc_restrict_flags_e_HWLOC_RESTRICT_FLAG_ADAPT_MISC: hwloc_restrict_flags_e = 2;
#[doc = " \\brief Move I/O objects to ancestors if their parents are removed during restriction."]
#[doc = " If this flag is not set, I/O devices and bridges are removed when their parents are removed."]
#[doc = " \\hideinitializer"]
pub const hwloc_restrict_flags_e_HWLOC_RESTRICT_FLAG_ADAPT_IO: hwloc_restrict_flags_e = 4;
#[doc = " \\brief Flags to be given to hwloc_topology_restrict()."]
pub type hwloc_restrict_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Restrict the topology to the given CPU set or nodeset."]
    #[doc = ""]
    #[doc = " Topology \\p topology is modified so as to remove all objects that"]
    #[doc = " are not included (or partially included) in the CPU set \\p set."]
    #[doc = " All objects CPU and node sets are restricted accordingly."]
    #[doc = ""]
    #[doc = " By default, \\p set is a CPU set. It means that the set of PUs in"]
    #[doc = " the topology is restricted. Once some PUs got removed, their parents"]
    #[doc = " may also get removed recursively if they became child-less."]
    #[doc = ""]
    #[doc = " If ::HWLOC_RESTRICT_FLAG_BYNODESET is passed in \\p flags,"]
    #[doc = " \\p set is considered a nodeset instead of a CPU set."]
    #[doc = " It means that the set of NUMA nodes in the topology is restricted"]
    #[doc = " (instead of PUs). Once some NUMA nodes got removed, their parents"]
    #[doc = " may also get removed recursively if they became child-less."]
    #[doc = ""]
    #[doc = " \\p flags is a OR'ed set of ::hwloc_restrict_flags_e."]
    #[doc = ""]
    #[doc = " \\note Restricting the topology removes some locality information,"]
    #[doc = " hence the remaining objects may get reordered (including PUs and NUMA nodes),"]
    #[doc = " and their logical indexes may change."]
    #[doc = ""]
    #[doc = " \\note This call may not be reverted by restricting back to a larger"]
    #[doc = " set. Once dropped during restriction, objects may not be brought"]
    #[doc = " back, except by loading another topology with hwloc_topology_load()."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = ""]
    #[doc = " \\return -1 with errno set to \\c EINVAL if the input set is invalid."]
    #[doc = " The topology is not modified in this case."]
    #[doc = ""]
    #[doc = " \\return -1 with errno set to \\c ENOMEM on failure to allocate internal data."]
    #[doc = " The topology is reinitialized in this case. It should be either"]
    #[doc = " destroyed with hwloc_topology_destroy() or configured and loaded again."]
    pub fn hwloc_topology_restrict(
        topology: hwloc_topology_t,
        set: hwloc_const_bitmap_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Mark all objects as allowed in the topology."]
#[doc = ""]
#[doc = " \\p cpuset and \\p nođeset given to hwloc_topology_allow() must be \\c NULL."]
#[doc = " \\hideinitializer"]
pub const hwloc_allow_flags_e_HWLOC_ALLOW_FLAG_ALL: hwloc_allow_flags_e = 1;
#[doc = " \\brief Only allow objects that are available to the current process."]
#[doc = ""]
#[doc = " The topology must have ::HWLOC_TOPOLOGY_FLAG_IS_THISSYSTEM so that the set"]
#[doc = " of available resources can actually be retrieved from the operating system."]
#[doc = ""]
#[doc = " \\p cpuset and \\p nođeset given to hwloc_topology_allow() must be \\c NULL."]
#[doc = " \\hideinitializer"]
pub const hwloc_allow_flags_e_HWLOC_ALLOW_FLAG_LOCAL_RESTRICTIONS: hwloc_allow_flags_e = 2;
#[doc = " \\brief Allow a custom set of objects, given to hwloc_topology_allow() as \\p cpuset and/or \\p nodeset parameters."]
#[doc = " \\hideinitializer"]
pub const hwloc_allow_flags_e_HWLOC_ALLOW_FLAG_CUSTOM: hwloc_allow_flags_e = 4;
#[doc = " \\brief Flags to be given to hwloc_topology_allow()."]
pub type hwloc_allow_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Change the sets of allowed PUs and NUMA nodes in the topology."]
    #[doc = ""]
    #[doc = " This function only works if the ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED"]
    #[doc = " was set on the topology. It does not modify any object, it only changes"]
    #[doc = " the sets returned by hwloc_topology_get_allowed_cpuset() and"]
    #[doc = " hwloc_topology_get_allowed_nodeset()."]
    #[doc = ""]
    #[doc = " It is notably useful when importing a topology from another process"]
    #[doc = " running in a different Linux Cgroup."]
    #[doc = ""]
    #[doc = " \\p flags must be set to one flag among ::hwloc_allow_flags_e."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error."]
    #[doc = ""]
    #[doc = " \\note Removing objects from a topology should rather be performed with"]
    #[doc = " hwloc_topology_restrict()."]
    pub fn hwloc_topology_allow(
        topology: hwloc_topology_t,
        cpuset: hwloc_const_cpuset_t,
        nodeset: hwloc_const_nodeset_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add a MISC object as a leaf of the topology"]
    #[doc = ""]
    #[doc = " A new MISC object will be created and inserted into the topology at the"]
    #[doc = " position given by parent. It is appended to the list of existing Misc children,"]
    #[doc = " without ever adding any intermediate hierarchy level. This is useful for"]
    #[doc = " annotating the topology without actually changing the hierarchy."]
    #[doc = ""]
    #[doc = " \\p name is supposed to be unique across all Misc objects in the topology."]
    #[doc = " It will be duplicated to setup the new object attributes."]
    #[doc = ""]
    #[doc = " The new leaf object will not have any \\p cpuset."]
    #[doc = ""]
    #[doc = " \\return the newly-created object"]
    #[doc = ""]
    #[doc = " \\return \\c NULL on error."]
    #[doc = ""]
    #[doc = " \\return \\c NULL if Misc objects are filtered-out of the topology (::HWLOC_TYPE_FILTER_KEEP_NONE)."]
    #[doc = ""]
    #[doc = " \\note If \\p name contains some non-printable characters, they will"]
    #[doc = " be dropped when exporting to XML, see hwloc_topology_export_xml() in hwloc/export.h."]
    pub fn hwloc_topology_insert_misc_object(
        topology: hwloc_topology_t,
        parent: hwloc_obj_t,
        name: *const ::std::os::raw::c_char,
    ) -> hwloc_obj_t;
}
extern "C" {
    #[doc = " \\brief Allocate a Group object to insert later with hwloc_topology_insert_group_object()."]
    #[doc = ""]
    #[doc = " This function returns a new Group object."]
    #[doc = ""]
    #[doc = " The caller should (at least) initialize its sets before inserting"]
    #[doc = " the object in the topology, see hwloc_topology_insert_group_object()."]
    #[doc = " Or it may decide not to insert and just free the group object"]
    #[doc = " by calling hwloc_topology_free_group_object()."]
    #[doc = ""]
    #[doc = " \\return The allocated object on success."]
    #[doc = " \\return \\c NULL on error."]
    #[doc = ""]
    #[doc = " \\note If successfully inserted by hwloc_topology_insert_group_object(),"]
    #[doc = " the object will be freed when the entire topology is freed."]
    #[doc = " If insertion failed (e.g. \\c NULL or empty CPU and node-sets),"]
    #[doc = " it is freed before returning the error."]
    pub fn hwloc_topology_alloc_group_object(topology: hwloc_topology_t) -> hwloc_obj_t;
}
extern "C" {
    #[doc = " \\brief Free a group object allocated with hwloc_topology_alloc_group_object()."]
    #[doc = ""]
    #[doc = " This function is only useful if the group object was not given"]
    #[doc = " to hwloc_topology_insert_group_object() as planned."]
    #[doc = ""]
    #[doc = " \\note \\p topology must be the same as the one previously passed"]
    #[doc = " to hwloc_topology_alloc_group_object()."]
    #[doc = ""]
    #[doc = " \\return \\c 0 on success."]
    #[doc = " \\return \\c -1 on error, for instance if an invalid topology is given."]
    pub fn hwloc_topology_free_group_object(
        topology: hwloc_topology_t,
        group: hwloc_obj_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Add more structure to the topology by adding an intermediate Group"]
    #[doc = ""]
    #[doc = " The caller should first allocate a new Group object with hwloc_topology_alloc_group_object()."]
    #[doc = " Then it must setup at least one of its CPU or node sets to specify"]
    #[doc = " the final location of the Group in the topology."]
    #[doc = " Then the object can be passed to this function for actual insertion in the topology."]
    #[doc = ""]
    #[doc = " Either the cpuset or nodeset field (or both, if compatible) must be set"]
    #[doc = " to a non-empty bitmap. The complete_cpuset or complete_nodeset may be set"]
    #[doc = " instead if inserting with respect to the complete topology"]
    #[doc = " (including disallowed, offline or unknown objects)."]
    #[doc = " If grouping several objects, hwloc_obj_add_other_obj_sets() is an easy way"]
    #[doc = " to build the Group sets iteratively."]
    #[doc = " These sets cannot be larger than the current topology, or they would get"]
    #[doc = " restricted silently."]
    #[doc = " The core will setup the other sets after actual insertion."]
    #[doc = ""]
    #[doc = " The \\p subtype object attribute may be defined (to a dynamically"]
    #[doc = " allocated string) to display something else than \"Group\" as the"]
    #[doc = " type name for this object in lstopo."]
    #[doc = " Custom name-value info pairs may be added with hwloc_obj_add_info() after"]
    #[doc = " insertion."]
    #[doc = ""]
    #[doc = " The group \\p dont_merge attribute may be set to \\c 1 to prevent"]
    #[doc = " the hwloc core from ever merging this object with another"]
    #[doc = " hierarchically-identical object."]
    #[doc = " This is useful when the Group itself describes an important feature"]
    #[doc = " that cannot be exposed anywhere else in the hierarchy."]
    #[doc = ""]
    #[doc = " The group \\p kind attribute may be set to a high value such"]
    #[doc = " as \\c 0xffffffff to tell hwloc that this new Group should always"]
    #[doc = " be discarded in favor of any existing Group with the same locality."]
    #[doc = ""]
    #[doc = " \\note Inserting a group adds some locality information to the topology,"]
    #[doc = " hence the existing objects may get reordered (including PUs and NUMA nodes),"]
    #[doc = " and their logical indexes may change."]
    #[doc = ""]
    #[doc = " \\note If the insertion fails, the input group object is freed."]
    #[doc = ""]
    #[doc = " \\note If the group object should be discarded instead of inserted,"]
    #[doc = " it may be passed to hwloc_topology_free_group_object() instead."]
    #[doc = ""]
    #[doc = " \\note \\p topology must be the same as the one previously passed"]
    #[doc = " to hwloc_topology_alloc_group_object()."]
    #[doc = ""]
    #[doc = " \\return The inserted object if it was properly inserted."]
    #[doc = ""]
    #[doc = " \\return An existing object if the Group was merged or discarded"]
    #[doc = " because the topology already contained an object at the same"]
    #[doc = " location (the Group did not add any hierarchy information)."]
    #[doc = ""]
    #[doc = " \\return \\c NULL if the insertion failed because of conflicting sets in topology tree."]
    #[doc = ""]
    #[doc = " \\return \\c NULL if Group objects are filtered-out of the topology (::HWLOC_TYPE_FILTER_KEEP_NONE)."]
    #[doc = ""]
    #[doc = " \\return \\c NULL if the object was discarded because no set was"]
    #[doc = " initialized in the Group before insert, or all of them were empty."]
    pub fn hwloc_topology_insert_group_object(
        topology: hwloc_topology_t,
        group: hwloc_obj_t,
    ) -> hwloc_obj_t;
}
extern "C" {
    #[doc = " \\brief Setup object cpusets/nodesets by OR'ing another object's sets."]
    #[doc = ""]
    #[doc = " For each defined cpuset or nodeset in \\p src, allocate the corresponding set"]
    #[doc = " in \\p dst and add \\p src to it by OR'ing sets."]
    #[doc = ""]
    #[doc = " This function is convenient between hwloc_topology_alloc_group_object()"]
    #[doc = " and hwloc_topology_insert_group_object(). It builds the sets of the new Group"]
    #[doc = " that will be inserted as a new intermediate parent of several objects."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c ENOMEM if some internal reallocation failed."]
    pub fn hwloc_obj_add_other_obj_sets(
        dst: hwloc_obj_t,
        src: hwloc_obj_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Refresh internal structures after topology modification."]
    #[doc = ""]
    #[doc = " Modifying the topology (by restricting, adding objects, modifying structures"]
    #[doc = " such as distances or memory attributes, etc.) may cause some internal caches"]
    #[doc = " to become invalid. These caches are automatically refreshed when accessed"]
    #[doc = " but this refreshing is not thread-safe."]
    #[doc = ""]
    #[doc = " This function is not thread-safe either, but it is a good way to end a"]
    #[doc = " non-thread-safe phase of topology modification. Once this refresh is done,"]
    #[doc = " multiple threads may concurrently consult the topology, objects, distances,"]
    #[doc = " attributes, etc."]
    #[doc = ""]
    #[doc = " See also \\ref threadsafety"]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 on error, for instance if some internal reallocation failed."]
    pub fn hwloc_topology_refresh(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is Normal."]
    #[doc = ""]
    #[doc = " Normal objects are objects of the main CPU hierarchy"]
    #[doc = " (Machine, Package, Core, PU, CPU caches, etc.),"]
    #[doc = " but they are not NUMA nodes, I/O devices or Misc objects."]
    #[doc = ""]
    #[doc = " They are attached to parent as Normal children,"]
    #[doc = " not as Memory, I/O or Misc children."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a Normal object, 0 otherwise."]
    pub fn hwloc_obj_type_is_normal(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is I/O."]
    #[doc = ""]
    #[doc = " I/O objects are objects attached to their parents"]
    #[doc = " in the I/O children list."]
    #[doc = " This current includes Bridges, PCI and OS devices."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a I/O object, 0 otherwise."]
    pub fn hwloc_obj_type_is_io(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is Memory."]
    #[doc = ""]
    #[doc = " Memory objects are objects attached to their parents"]
    #[doc = " in the Memory children list."]
    #[doc = " This current includes NUMA nodes and Memory-side caches."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a Memory object, 0 otherwise."]
    pub fn hwloc_obj_type_is_memory(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is a CPU Cache (Data, Unified or Instruction)."]
    #[doc = ""]
    #[doc = " Memory-side caches are not CPU caches."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a Cache, 0 otherwise."]
    pub fn hwloc_obj_type_is_cache(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is a CPU Data or Unified Cache."]
    #[doc = ""]
    #[doc = " Memory-side caches are not CPU caches."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a CPU Data or Unified Cache, 0 otherwise."]
    pub fn hwloc_obj_type_is_dcache(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Check whether an object type is a CPU Instruction Cache,"]
    #[doc = ""]
    #[doc = " Memory-side caches are not CPU caches."]
    #[doc = ""]
    #[doc = " \\return 1 if an object of type \\p type is a CPU Instruction Cache, 0 otherwise."]
    pub fn hwloc_obj_type_is_icache(type_: hwloc_obj_type_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the set of largest objects covering exactly a given cpuset \\p set"]
    #[doc = ""]
    #[doc = " \\return the number of objects returned in \\p objs."]
    #[doc = " \\return -1 if no set of objects may cover that cpuset."]
    pub fn hwloc_get_largest_objs_inside_cpuset(
        topology: hwloc_topology_t,
        set: hwloc_const_cpuset_t,
        objs: *mut hwloc_obj_t,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Remove simultaneous multithreading PUs from a CPU set."]
    #[doc = ""]
    #[doc = " For each core in \\p topology, if \\p cpuset contains some PUs of that core,"]
    #[doc = " modify \\p cpuset to only keep a single PU for that core."]
    #[doc = ""]
    #[doc = " \\p which specifies which PU will be kept."]
    #[doc = " PU are considered in physical index order."]
    #[doc = " If 0, for each core, the function keeps the first PU that was originally set in \\p cpuset."]
    #[doc = ""]
    #[doc = " If \\p which is larger than the number of PUs in a core there were originally set in \\p cpuset,"]
    #[doc = " no PU is kept for that core."]
    #[doc = ""]
    #[doc = " \\return 0."]
    #[doc = ""]
    #[doc = " \\note PUs that are not below a Core object are ignored"]
    #[doc = " (for instance if the topology does not contain any Core object)."]
    #[doc = " None of them is removed from \\p cpuset."]
    pub fn hwloc_bitmap_singlify_per_core(
        topology: hwloc_topology_t,
        cpuset: hwloc_bitmap_t,
        which: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Do a depth-first traversal of the topology to find and sort"]
    #[doc = ""]
    #[doc = " all objects that are at the same depth than \\p src."]
    #[doc = " Report in \\p objs up to \\p max physically closest ones to \\p src."]
    #[doc = ""]
    #[doc = " \\return the number of objects returned in \\p objs."]
    #[doc = ""]
    #[doc = " \\return 0 if \\p src is an I/O object."]
    #[doc = ""]
    #[doc = " \\note This function requires the \\p src object to have a CPU set."]
    pub fn hwloc_get_closest_objs(
        topology: hwloc_topology_t,
        src: hwloc_obj_t,
        objs: *mut hwloc_obj_t,
        max: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " \\brief Return an object of a different type with same locality."]
    #[doc = ""]
    #[doc = " If the source object \\p src is a normal or memory type,"]
    #[doc = " this function returns an object of type \\p type with same"]
    #[doc = " CPU and node sets, either below or above in the hierarchy."]
    #[doc = ""]
    #[doc = " If the source object \\p src is a PCI or an OS device within a PCI"]
    #[doc = " device, the function may either return that PCI device, or another"]
    #[doc = " OS device in the same PCI parent."]
    #[doc = " This may for instance be useful for converting between OS devices"]
    #[doc = " such as \"nvml0\" or \"rsmi1\" used in distance structures into the"]
    #[doc = " the PCI device, or the CUDA or OpenCL OS device that correspond"]
    #[doc = " to the same physical card."]
    #[doc = ""]
    #[doc = " If not \\c NULL, parameter \\p subtype only select objects whose"]
    #[doc = " subtype attribute exists and is \\p subtype (case-insensitively),"]
    #[doc = " for instance \"OpenCL\" or \"CUDA\"."]
    #[doc = ""]
    #[doc = " If not \\c NULL, parameter \\p nameprefix only selects objects whose"]
    #[doc = " name attribute exists and starts with \\p nameprefix (case-insensitively),"]
    #[doc = " for instance \"rsmi\" for matching \"rsmi0\"."]
    #[doc = ""]
    #[doc = " If multiple objects match, the first one is returned."]
    #[doc = ""]
    #[doc = " This function will not walk the hierarchy across bridges since"]
    #[doc = " the PCI locality may become different."]
    #[doc = " This function cannot also convert between normal/memory objects"]
    #[doc = " and I/O or Misc objects."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\return An object with identical locality,"]
    #[doc = " matching \\p subtype and \\p nameprefix if any."]
    #[doc = ""]
    #[doc = " \\return \\c NULL if no matching object could be found,"]
    #[doc = " or if the source object and target type are incompatible,"]
    #[doc = " for instance if converting between CPU and I/O objects."]
    pub fn hwloc_get_obj_with_same_locality(
        topology: hwloc_topology_t,
        src: hwloc_obj_t,
        type_: hwloc_obj_type_t,
        subtype: *const ::std::os::raw::c_char,
        nameprefix: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_ulong,
    ) -> hwloc_obj_t;
}
#[doc = " \\brief Distrib in reverse order, starting from the last objects."]
#[doc = " \\hideinitializer"]
pub const hwloc_distrib_flags_e_HWLOC_DISTRIB_FLAG_REVERSE: hwloc_distrib_flags_e = 1;
#[doc = " \\brief Flags to be given to hwloc_distrib()."]
pub type hwloc_distrib_flags_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Get complete CPU set"]
    #[doc = ""]
    #[doc = " \\return the complete CPU set of processors of the system."]
    #[doc = ""]
    #[doc = " \\note This function cannot return \\c NULL."]
    #[doc = ""]
    #[doc = " \\note The returned cpuset is not newly allocated and should thus not be"]
    #[doc = " changed or freed; hwloc_bitmap_dup() must be used to obtain a local copy."]
    #[doc = ""]
    #[doc = " \\note This is equivalent to retrieving the root object complete CPU-set."]
    pub fn hwloc_topology_get_complete_cpuset(topology: hwloc_topology_t) -> hwloc_const_cpuset_t;
}
extern "C" {
    #[doc = " \\brief Get topology CPU set"]
    #[doc = ""]
    #[doc = " \\return the CPU set of processors of the system for which hwloc"]
    #[doc = " provides topology information. This is equivalent to the cpuset of the"]
    #[doc = " system object."]
    #[doc = ""]
    #[doc = " \\note This function cannot return \\c NULL."]
    #[doc = ""]
    #[doc = " \\note The returned cpuset is not newly allocated and should thus not be"]
    #[doc = " changed or freed; hwloc_bitmap_dup() must be used to obtain a local copy."]
    #[doc = ""]
    #[doc = " \\note This is equivalent to retrieving the root object CPU-set."]
    pub fn hwloc_topology_get_topology_cpuset(topology: hwloc_topology_t) -> hwloc_const_cpuset_t;
}
extern "C" {
    #[doc = " \\brief Get allowed CPU set"]
    #[doc = ""]
    #[doc = " \\return the CPU set of allowed processors of the system."]
    #[doc = ""]
    #[doc = " \\note This function cannot return \\c NULL."]
    #[doc = ""]
    #[doc = " \\note If the topology flag ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED was not set,"]
    #[doc = " this is identical to hwloc_topology_get_topology_cpuset(), which means"]
    #[doc = " all PUs are allowed."]
    #[doc = ""]
    #[doc = " \\note If ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED was set, applying"]
    #[doc = " hwloc_bitmap_intersects() on the result of this function and on an object"]
    #[doc = " cpuset checks whether there are allowed PUs inside that object."]
    #[doc = " Applying hwloc_bitmap_and() returns the list of these allowed PUs."]
    #[doc = ""]
    #[doc = " \\note The returned cpuset is not newly allocated and should thus not be"]
    #[doc = " changed or freed, hwloc_bitmap_dup() must be used to obtain a local copy."]
    pub fn hwloc_topology_get_allowed_cpuset(topology: hwloc_topology_t) -> hwloc_const_cpuset_t;
}
extern "C" {
    #[doc = " \\brief Get complete node set"]
    #[doc = ""]
    #[doc = " \\return the complete node set of memory of the system."]
    #[doc = ""]
    #[doc = " \\note This function cannot return \\c NULL."]
    #[doc = ""]
    #[doc = " \\note The returned nodeset is not newly allocated and should thus not be"]
    #[doc = " changed or freed; hwloc_bitmap_dup() must be used to obtain a local copy."]
    #[doc = ""]
    #[doc = " \\note This is equivalent to retrieving the root object complete nodeset."]
    pub fn hwloc_topology_get_complete_nodeset(topology: hwloc_topology_t)
        -> hwloc_const_nodeset_t;
}
extern "C" {
    #[doc = " \\brief Get topology node set"]
    #[doc = ""]
    #[doc = " \\return the node set of memory of the system for which hwloc"]
    #[doc = " provides topology information. This is equivalent to the nodeset of the"]
    #[doc = " system object."]
    #[doc = ""]
    #[doc = " \\note This function cannot return \\c NULL."]
    #[doc = ""]
    #[doc = " \\note The returned nodeset is not newly allocated and should thus not be"]
    #[doc = " changed or freed; hwloc_bitmap_dup() must be used to obtain a local copy."]
    #[doc = ""]
    #[doc = " \\note This is equivalent to retrieving the root object nodeset."]
    pub fn hwloc_topology_get_topology_nodeset(topology: hwloc_topology_t)
        -> hwloc_const_nodeset_t;
}
extern "C" {
    #[doc = " \\brief Get allowed node set"]
    #[doc = ""]
    #[doc = " \\return the node set of allowed memory of the system."]
    #[doc = ""]
    #[doc = " \\note This function cannot return \\c NULL."]
    #[doc = ""]
    #[doc = " \\note If the topology flag ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED was not set,"]
    #[doc = " this is identical to hwloc_topology_get_topology_nodeset(), which means"]
    #[doc = " all NUMA nodes are allowed."]
    #[doc = ""]
    #[doc = " \\note If ::HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED was set, applying"]
    #[doc = " hwloc_bitmap_intersects() on the result of this function and on an object"]
    #[doc = " nodeset checks whether there are allowed NUMA nodes inside that object."]
    #[doc = " Applying hwloc_bitmap_and() returns the list of these allowed NUMA nodes."]
    #[doc = ""]
    #[doc = " \\note The returned nodeset is not newly allocated and should thus not be"]
    #[doc = " changed or freed, hwloc_bitmap_dup() must be used to obtain a local copy."]
    pub fn hwloc_topology_get_allowed_nodeset(topology: hwloc_topology_t) -> hwloc_const_nodeset_t;
}
#[doc = " \\brief"]
#[doc = " The \\\"Capacity\\\" is returned in bytes (local_memory attribute in objects)."]
#[doc = ""]
#[doc = " Best capacity nodes are nodes with <b>higher capacity</b>."]
#[doc = ""]
#[doc = " No initiator is involved when looking at this attribute."]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_HIGHER_FIRST."]
#[doc = " \\hideinitializer"]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_CAPACITY: hwloc_memattr_id_e = 0;
#[doc = " \\brief"]
#[doc = " The \\\"Locality\\\" is returned as the number of PUs in that locality"]
#[doc = " (e.g. the weight of its cpuset)."]
#[doc = ""]
#[doc = " Best locality nodes are nodes with <b>smaller locality</b>"]
#[doc = " (nodes that are local to very few PUs)."]
#[doc = " Poor locality nodes are nodes with larger locality"]
#[doc = " (nodes that are local to the entire machine)."]
#[doc = ""]
#[doc = " No initiator is involved when looking at this attribute."]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_HIGHER_FIRST."]
#[doc = " \\hideinitializer"]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_LOCALITY: hwloc_memattr_id_e = 1;
#[doc = " \\brief"]
#[doc = " The \\\"Bandwidth\\\" is returned in MiB/s, as seen from the given initiator location."]
#[doc = ""]
#[doc = " Best bandwidth nodes are nodes with <b>higher bandwidth</b>."]
#[doc = ""]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_HIGHER_FIRST"]
#[doc = " and ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR."]
#[doc = ""]
#[doc = " This is the average bandwidth for read and write accesses. If the platform"]
#[doc = " provides individual read and write bandwidths but no explicit average value,"]
#[doc = " hwloc computes and returns the average."]
#[doc = " \\hideinitializer"]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_BANDWIDTH: hwloc_memattr_id_e = 2;
#[doc = " \\brief"]
#[doc = " The \\\"ReadBandwidth\\\" is returned in MiB/s, as seen from the given initiator location."]
#[doc = ""]
#[doc = " Best bandwidth nodes are nodes with <b>higher bandwidth</b>."]
#[doc = ""]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_HIGHER_FIRST"]
#[doc = " and ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR."]
#[doc = " \\hideinitializer"]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_READ_BANDWIDTH: hwloc_memattr_id_e = 4;
#[doc = " \\brief"]
#[doc = " The \\\"WriteBandwidth\\\" is returned in MiB/s, as seen from the given initiator location."]
#[doc = ""]
#[doc = " Best bandwidth nodes are nodes with <b>higher bandwidth</b>."]
#[doc = ""]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_HIGHER_FIRST"]
#[doc = " and ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR."]
#[doc = " \\hideinitializer"]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_WRITE_BANDWIDTH: hwloc_memattr_id_e = 5;
#[doc = " \\brief"]
#[doc = " The \\\"Latency\\\" is returned as nanoseconds, as seen from the given initiator location."]
#[doc = ""]
#[doc = " Best latency nodes are nodes with <b>smaller latency</b>."]
#[doc = ""]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_LOWER_FIRST"]
#[doc = " and ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR."]
#[doc = ""]
#[doc = " This is the average latency for read and write accesses. If the platform"]
#[doc = " provides individual read and write latencies but no explicit average value,"]
#[doc = " hwloc computes and returns the average."]
#[doc = " \\hideinitializer"]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_LATENCY: hwloc_memattr_id_e = 3;
#[doc = " \\brief"]
#[doc = " The \\\"ReadLatency\\\" is returned as nanoseconds, as seen from the given initiator location."]
#[doc = ""]
#[doc = " Best latency nodes are nodes with <b>smaller latency</b>."]
#[doc = ""]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_LOWER_FIRST"]
#[doc = " and ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR."]
#[doc = " \\hideinitializer"]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_READ_LATENCY: hwloc_memattr_id_e = 6;
#[doc = " \\brief"]
#[doc = " The \\\"WriteLatency\\\" is returned as nanoseconds, as seen from the given initiator location."]
#[doc = ""]
#[doc = " Best latency nodes are nodes with <b>smaller latency</b>."]
#[doc = ""]
#[doc = " The corresponding attribute flags are ::HWLOC_MEMATTR_FLAG_LOWER_FIRST"]
#[doc = " and ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR."]
#[doc = " \\hideinitializer"]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_WRITE_LATENCY: hwloc_memattr_id_e = 7;
#[doc = "< \\private Sentinel value"]
pub const hwloc_memattr_id_e_HWLOC_MEMATTR_ID_MAX: hwloc_memattr_id_e = 8;
#[doc = " \\brief Memory node attributes."]
pub type hwloc_memattr_id_e = ::std::os::raw::c_uint;
#[doc = " \\brief A memory attribute identifier."]
#[doc = " May be either one of ::hwloc_memattr_id_e or a new id returned by hwloc_memattr_register()."]
pub type hwloc_memattr_id_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Return the identifier of the memory attribute with the given name."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c EINVAL if no such attribute exists."]
    pub fn hwloc_memattr_get_by_name(
        topology: hwloc_topology_t,
        name: *const ::std::os::raw::c_char,
        id: *mut hwloc_memattr_id_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief Location is given as a cpuset, in the location cpuset union field. \\hideinitializer"]
pub const hwloc_location_type_e_HWLOC_LOCATION_TYPE_CPUSET: hwloc_location_type_e = 1;
#[doc = " \\brief Location is given as an object, in the location object union field. \\hideinitializer"]
pub const hwloc_location_type_e_HWLOC_LOCATION_TYPE_OBJECT: hwloc_location_type_e = 0;
#[doc = " \\brief Type of location."]
pub type hwloc_location_type_e = ::std::os::raw::c_uint;
#[doc = " \\brief Where to measure attributes from."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hwloc_location {
    #[doc = " \\brief Type of location."]
    pub type_: hwloc_location_type_e,
    pub location: hwloc_location_hwloc_location_u,
}
#[doc = " \\brief Actual location."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_location_hwloc_location_u {
    #[doc = " \\brief Location as a cpuset, when the location type is ::HWLOC_LOCATION_TYPE_CPUSET."]
    pub cpuset: hwloc_cpuset_t,
    #[doc = " \\brief Location as an object, when the location type is ::HWLOC_LOCATION_TYPE_OBJECT."]
    pub object: hwloc_obj_t,
}
#[test]
fn bindgen_test_layout_hwloc_location_hwloc_location_u() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_location_hwloc_location_u>(),
        8usize,
        concat!("Size of: ", stringify!(hwloc_location_hwloc_location_u))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_location_hwloc_location_u>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_location_hwloc_location_u))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_location_hwloc_location_u>())).cpuset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_location_hwloc_location_u),
            "::",
            stringify!(cpuset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_location_hwloc_location_u>())).object as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_location_hwloc_location_u),
            "::",
            stringify!(object)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_location() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_location>(),
        16usize,
        concat!("Size of: ", stringify!(hwloc_location))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_location>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_location))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_location>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_location),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_location>())).location as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_location),
            "::",
            stringify!(location)
        )
    );
}
#[doc = " \\brief Select NUMA nodes whose locality is larger than the given cpuset."]
#[doc = " For instance, if a single PU (or its cpuset) is given in \\p initiator,"]
#[doc = " select all nodes close to the package that contains this PU."]
#[doc = " \\hideinitializer"]
pub const hwloc_local_numanode_flag_e_HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY:
    hwloc_local_numanode_flag_e = 1;
#[doc = " \\brief Select NUMA nodes whose locality is smaller than the given cpuset."]
#[doc = " For instance, if a package (or its cpuset) is given in \\p initiator,"]
#[doc = " also select nodes that are attached to only a half of that package."]
#[doc = " \\hideinitializer"]
pub const hwloc_local_numanode_flag_e_HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY:
    hwloc_local_numanode_flag_e = 2;
#[doc = " \\brief Select all NUMA nodes in the topology."]
#[doc = " The initiator \\p initiator is ignored."]
#[doc = " \\hideinitializer"]
pub const hwloc_local_numanode_flag_e_HWLOC_LOCAL_NUMANODE_FLAG_ALL: hwloc_local_numanode_flag_e =
    4;
#[doc = " \\brief Flags for selecting target NUMA nodes."]
pub type hwloc_local_numanode_flag_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Return an array of local NUMA nodes."]
    #[doc = ""]
    #[doc = " By default only select the NUMA nodes whose locality is exactly"]
    #[doc = " the given \\p location. More nodes may be selected if additional flags"]
    #[doc = " are given as a OR'ed set of ::hwloc_local_numanode_flag_e."]
    #[doc = ""]
    #[doc = " If \\p location is given as an explicit object, its CPU set is used"]
    #[doc = " to find NUMA nodes with the corresponding locality."]
    #[doc = " If the object does not have a CPU set (e.g. I/O object), the CPU"]
    #[doc = " parent (where the I/O object is attached) is used."]
    #[doc = ""]
    #[doc = " On input, \\p nr points to the number of nodes that may be stored"]
    #[doc = " in the \\p nodes array."]
    #[doc = " On output, \\p nr will be changed to the number of stored nodes,"]
    #[doc = " or the number of nodes that would have been stored if there were"]
    #[doc = " enough room."]
    #[doc = ""]
    #[doc = " \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = " \\note Some of these NUMA nodes may not have any memory attribute"]
    #[doc = " values and hence not be reported as actual targets in other functions."]
    #[doc = ""]
    #[doc = " \\note The number of NUMA nodes in the topology (obtained by"]
    #[doc = " hwloc_bitmap_weight() on the root object nodeset) may be used"]
    #[doc = " to allocate the \\p nodes array."]
    #[doc = ""]
    #[doc = " \\note When an object CPU set is given as locality, for instance a Package,"]
    #[doc = " and when flags contain both ::HWLOC_LOCAL_NUMANODE_FLAG_LARGER_LOCALITY"]
    #[doc = " and ::HWLOC_LOCAL_NUMANODE_FLAG_SMALLER_LOCALITY,"]
    #[doc = " the returned array corresponds to the nodeset of that object."]
    pub fn hwloc_get_local_numanode_objs(
        topology: hwloc_topology_t,
        location: *mut hwloc_location,
        nr: *mut ::std::os::raw::c_uint,
        nodes: *mut hwloc_obj_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return an attribute value for a specific target NUMA node."]
    #[doc = ""]
    #[doc = " If the attribute does not relate to a specific initiator"]
    #[doc = " (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR),"]
    #[doc = " location \\p initiator is ignored and may be \\c NULL."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 on error, for instance with errno set to \\c EINVAL if flags"]
    #[doc = " are invalid or no such attribute exists."]
    #[doc = ""]
    #[doc = " \\note The initiator \\p initiator should be of type ::HWLOC_LOCATION_TYPE_CPUSET"]
    #[doc = " when refering to accesses performed by CPU cores."]
    #[doc = " ::HWLOC_LOCATION_TYPE_OBJECT is currently unused internally by hwloc,"]
    #[doc = " but users may for instance use it to provide custom information about"]
    #[doc = " host memory accesses performed by GPUs."]
    pub fn hwloc_memattr_get_value(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        target_node: hwloc_obj_t,
        initiator: *mut hwloc_location,
        flags: ::std::os::raw::c_ulong,
        value: *mut hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the best target NUMA node for the given attribute and initiator."]
    #[doc = ""]
    #[doc = " If the attribute does not relate to a specific initiator"]
    #[doc = " (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR),"]
    #[doc = " location \\p initiator is ignored and may be \\c NULL."]
    #[doc = ""]
    #[doc = " If \\p value is non \\c NULL, the corresponding value is returned there."]
    #[doc = ""]
    #[doc = " If multiple targets have the same attribute values, only one is"]
    #[doc = " returned (and there is no way to clarify how that one is chosen)."]
    #[doc = " Applications that want to detect targets with identical/similar"]
    #[doc = " values, or that want to look at values for multiple attributes,"]
    #[doc = " should rather get all values using hwloc_memattr_get_value()"]
    #[doc = " and manually select the target they consider the best."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c ENOENT if there are no matching targets."]
    #[doc = " \\return -1 with errno set to \\c EINVAL if flags are invalid,"]
    #[doc = " or no such attribute exists."]
    #[doc = ""]
    #[doc = " \\note The initiator \\p initiator should be of type ::HWLOC_LOCATION_TYPE_CPUSET"]
    #[doc = " when refering to accesses performed by CPU cores."]
    #[doc = " ::HWLOC_LOCATION_TYPE_OBJECT is currently unused internally by hwloc,"]
    #[doc = " but users may for instance use it to provide custom information about"]
    #[doc = " host memory accesses performed by GPUs."]
    pub fn hwloc_memattr_get_best_target(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        initiator: *mut hwloc_location,
        flags: ::std::os::raw::c_ulong,
        best_target: *mut hwloc_obj_t,
        value: *mut hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the best initiator for the given attribute and target NUMA node."]
    #[doc = ""]
    #[doc = " If \\p value is non \\c NULL, the corresponding value is returned there."]
    #[doc = ""]
    #[doc = " If multiple initiators have the same attribute values, only one is"]
    #[doc = " returned (and there is no way to clarify how that one is chosen)."]
    #[doc = " Applications that want to detect initiators with identical/similar"]
    #[doc = " values, or that want to look at values for multiple attributes,"]
    #[doc = " should rather get all values using hwloc_memattr_get_value()"]
    #[doc = " and manually select the initiator they consider the best."]
    #[doc = ""]
    #[doc = " The returned initiator should not be modified or freed,"]
    #[doc = " it belongs to the topology."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c ENOENT if there are no matching initiators."]
    #[doc = " \\return -1 with errno set to \\c EINVAL if the attribute does not relate to a specific initiator"]
    #[doc = " (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR)."]
    pub fn hwloc_memattr_get_best_initiator(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        target: hwloc_obj_t,
        flags: ::std::os::raw::c_ulong,
        best_initiator: *mut hwloc_location,
        value: *mut hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the name of a memory attribute."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c EINVAL if the attribute does not exist."]
    pub fn hwloc_memattr_get_name(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the flags of the given attribute."]
    #[doc = ""]
    #[doc = " Flags are a OR'ed set of ::hwloc_memattr_flag_e."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c EINVAL if the attribute does not exist."]
    pub fn hwloc_memattr_get_flags(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        flags: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\brief The best nodes for this memory attribute are those with the higher values."]
#[doc = " For instance Bandwidth."]
pub const hwloc_memattr_flag_e_HWLOC_MEMATTR_FLAG_HIGHER_FIRST: hwloc_memattr_flag_e = 1;
#[doc = " \\brief The best nodes for this memory attribute are those with the lower values."]
#[doc = " For instance Latency."]
pub const hwloc_memattr_flag_e_HWLOC_MEMATTR_FLAG_LOWER_FIRST: hwloc_memattr_flag_e = 2;
#[doc = " \\brief The value returned for this memory attribute depends on the given initiator."]
#[doc = " For instance Bandwidth and Latency, but not Capacity."]
pub const hwloc_memattr_flag_e_HWLOC_MEMATTR_FLAG_NEED_INITIATOR: hwloc_memattr_flag_e = 4;
#[doc = " \\brief Memory attribute flags."]
#[doc = " Given to hwloc_memattr_register() and returned by hwloc_memattr_get_flags()."]
pub type hwloc_memattr_flag_e = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " \\brief Register a new memory attribute."]
    #[doc = ""]
    #[doc = " Add a specific memory attribute that is not defined in ::hwloc_memattr_id_e."]
    #[doc = " Flags are a OR'ed set of ::hwloc_memattr_flag_e. It must contain at least"]
    #[doc = " one of ::HWLOC_MEMATTR_FLAG_HIGHER_FIRST or ::HWLOC_MEMATTR_FLAG_LOWER_FIRST."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    #[doc = " \\return -1 with errno set to \\c EBUSY if another attribute already uses this name."]
    pub fn hwloc_memattr_register(
        topology: hwloc_topology_t,
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_ulong,
        id: *mut hwloc_memattr_id_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set an attribute value for a specific target NUMA node."]
    #[doc = ""]
    #[doc = " If the attribute does not relate to a specific initiator"]
    #[doc = " (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR),"]
    #[doc = " location \\p initiator is ignored and may be \\c NULL."]
    #[doc = ""]
    #[doc = " The initiator will be copied into the topology,"]
    #[doc = " the caller should free anything allocated to store the initiator,"]
    #[doc = " for instance the cpuset."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\note The initiator \\p initiator should be of type ::HWLOC_LOCATION_TYPE_CPUSET"]
    #[doc = " when referring to accesses performed by CPU cores."]
    #[doc = " ::HWLOC_LOCATION_TYPE_OBJECT is currently unused internally by hwloc,"]
    #[doc = " but users may for instance use it to provide custom information about"]
    #[doc = " host memory accesses performed by GPUs."]
    #[doc = ""]
    #[doc = " \\return 0 on success or -1 on error."]
    pub fn hwloc_memattr_set_value(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        target_node: hwloc_obj_t,
        initiator: *mut hwloc_location,
        flags: ::std::os::raw::c_ulong,
        value: hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the target NUMA nodes that have some values for a given attribute."]
    #[doc = ""]
    #[doc = " Return targets for the given attribute in the \\p targets array"]
    #[doc = " (for the given initiator if any)."]
    #[doc = " If \\p values is not \\c NULL, the corresponding attribute values"]
    #[doc = " are stored in the array it points to."]
    #[doc = ""]
    #[doc = " On input, \\p nr points to the number of targets that may be stored"]
    #[doc = " in the array \\p targets (and \\p values)."]
    #[doc = " On output, \\p nr points to the number of targets (and values) that"]
    #[doc = " were actually found, even if some of them couldn't be stored in the array."]
    #[doc = " Targets that couldn't be stored are ignored, but the function still"]
    #[doc = " returns success (\\c 0). The caller may find out by comparing the value pointed"]
    #[doc = " by \\p nr before and after the function call."]
    #[doc = ""]
    #[doc = " The returned targets should not be modified or freed,"]
    #[doc = " they belong to the topology."]
    #[doc = ""]
    #[doc = " Argument \\p initiator is ignored if the attribute does not relate to a specific"]
    #[doc = " initiator (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR)."]
    #[doc = " Otherwise \\p initiator may be non \\c NULL to report only targets"]
    #[doc = " that have a value for that initiator."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " \\note This function is meant for tools and debugging (listing internal information)"]
    #[doc = " rather than for application queries. Applications should rather select useful"]
    #[doc = " NUMA nodes with hwloc_get_local_numanode_objs() and then look at their attribute"]
    #[doc = " values."]
    #[doc = ""]
    #[doc = " \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = " \\note The initiator \\p initiator should be of type ::HWLOC_LOCATION_TYPE_CPUSET"]
    #[doc = " when referring to accesses performed by CPU cores."]
    #[doc = " ::HWLOC_LOCATION_TYPE_OBJECT is currently unused internally by hwloc,"]
    #[doc = " but users may for instance use it to provide custom information about"]
    #[doc = " host memory accesses performed by GPUs."]
    pub fn hwloc_memattr_get_targets(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        initiator: *mut hwloc_location,
        flags: ::std::os::raw::c_ulong,
        nr: *mut ::std::os::raw::c_uint,
        targets: *mut hwloc_obj_t,
        values: *mut hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Return the initiators that have values for a given attribute for a specific target NUMA node."]
    #[doc = ""]
    #[doc = " Return initiators for the given attribute and target node in the"]
    #[doc = " \\p initiators array."]
    #[doc = " If \\p values is not \\c NULL, the corresponding attribute values"]
    #[doc = " are stored in the array it points to."]
    #[doc = ""]
    #[doc = " On input, \\p nr points to the number of initiators that may be stored"]
    #[doc = " in the array \\p initiators (and \\p values)."]
    #[doc = " On output, \\p nr points to the number of initiators (and values) that"]
    #[doc = " were actually found, even if some of them couldn't be stored in the array."]
    #[doc = " Initiators that couldn't be stored are ignored, but the function still"]
    #[doc = " returns success (\\c 0). The caller may find out by comparing the value pointed"]
    #[doc = " by \\p nr before and after the function call."]
    #[doc = ""]
    #[doc = " The returned initiators should not be modified or freed,"]
    #[doc = " they belong to the topology."]
    #[doc = ""]
    #[doc = " \\p flags must be \\c 0 for now."]
    #[doc = ""]
    #[doc = " If the attribute does not relate to a specific initiator"]
    #[doc = " (it does not have the flag ::HWLOC_MEMATTR_FLAG_NEED_INITIATOR),"]
    #[doc = " no initiator is returned."]
    #[doc = ""]
    #[doc = " \\return 0 on success or -1 on error."]
    #[doc = ""]
    #[doc = " \\note This function is meant for tools and debugging (listing internal information)"]
    #[doc = " rather than for application queries. Applications should rather select useful"]
    #[doc = " NUMA nodes with hwloc_get_local_numanode_objs() and then look at their attribute"]
    #[doc = " values for some relevant initiators."]
    pub fn hwloc_memattr_get_initiators(
        topology: hwloc_topology_t,
        attribute: hwloc_memattr_id_t,
        target_node: hwloc_obj_t,
        flags: ::std::os::raw::c_ulong,
        nr: *mut ::std::os::raw::c_uint,
        initiators: *mut hwloc_location,
        values: *mut hwloc_uint64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_cpukinds_get_nr(
        topology: hwloc_topology_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_cpukinds_get_by_cpuset(
        topology: hwloc_topology_t,
        cpuset: hwloc_const_bitmap_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_cpukinds_get_info(
        topology: hwloc_topology_t,
        kind_index: ::std::os::raw::c_uint,
        cpuset: hwloc_bitmap_t,
        efficiency: *mut ::std::os::raw::c_int,
        nr_infos: *mut ::std::os::raw::c_uint,
        infos: *mut *mut hwloc_info_s,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_cpukinds_register(
        topology: hwloc_topology_t,
        cpuset: hwloc_bitmap_t,
        forced_efficiency: ::std::os::raw::c_int,
        nr_infos: ::std::os::raw::c_uint,
        infos: *mut hwloc_info_s,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
pub const hwloc_topology_export_xml_flags_e_HWLOC_TOPOLOGY_EXPORT_XML_FLAG_V1:
    hwloc_topology_export_xml_flags_e = 1;
pub type hwloc_topology_export_xml_flags_e = ::std::os::raw::c_uint;
extern "C" {
    pub fn hwloc_topology_export_xml(
        topology: hwloc_topology_t,
        xmlpath: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_topology_export_xmlbuffer(
        topology: hwloc_topology_t,
        xmlbuffer: *mut *mut ::std::os::raw::c_char,
        buflen: *mut ::std::os::raw::c_int,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_free_xmlbuffer(topology: hwloc_topology_t, xmlbuffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn hwloc_topology_set_userdata_export_callback(
        topology: hwloc_topology_t,
        export_cb: ::std::option::Option<
            unsafe extern "C" fn(
                reserved: *mut ::std::os::raw::c_void,
                topology: hwloc_topology_t,
                obj: hwloc_obj_t,
            ),
        >,
    );
}
extern "C" {
    pub fn hwloc_export_obj_userdata(
        reserved: *mut ::std::os::raw::c_void,
        topology: hwloc_topology_t,
        obj: hwloc_obj_t,
        name: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_export_obj_userdata_base64(
        reserved: *mut ::std::os::raw::c_void,
        topology: hwloc_topology_t,
        obj: hwloc_obj_t,
        name: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_void,
        length: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_topology_set_userdata_import_callback(
        topology: hwloc_topology_t,
        import_cb: ::std::option::Option<
            unsafe extern "C" fn(
                topology: hwloc_topology_t,
                obj: hwloc_obj_t,
                name: *const ::std::os::raw::c_char,
                buffer: *const ::std::os::raw::c_void,
                length: size_t,
            ),
        >,
    );
}
pub const hwloc_topology_export_synthetic_flags_e_HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_EXTENDED_TYPES : hwloc_topology_export_synthetic_flags_e = 1 ;
pub const hwloc_topology_export_synthetic_flags_e_HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_NO_ATTRS:
    hwloc_topology_export_synthetic_flags_e = 2;
pub const hwloc_topology_export_synthetic_flags_e_HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_V1:
    hwloc_topology_export_synthetic_flags_e = 4;
pub const hwloc_topology_export_synthetic_flags_e_HWLOC_TOPOLOGY_EXPORT_SYNTHETIC_FLAG_IGNORE_MEMORY : hwloc_topology_export_synthetic_flags_e = 8 ;
pub type hwloc_topology_export_synthetic_flags_e = ::std::os::raw::c_uint;
extern "C" {
    pub fn hwloc_topology_export_synthetic(
        topology: hwloc_topology_t,
        buffer: *mut ::std::os::raw::c_char,
        buflen: size_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_distances_s {
    pub nbobjs: ::std::os::raw::c_uint,
    pub objs: *mut hwloc_obj_t,
    pub kind: ::std::os::raw::c_ulong,
    pub values: *mut hwloc_uint64_t,
}
#[test]
fn bindgen_test_layout_hwloc_distances_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_distances_s>(),
        32usize,
        concat!("Size of: ", stringify!(hwloc_distances_s))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_distances_s>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_distances_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_distances_s>())).nbobjs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_distances_s),
            "::",
            stringify!(nbobjs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_distances_s>())).objs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_distances_s),
            "::",
            stringify!(objs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_distances_s>())).kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_distances_s),
            "::",
            stringify!(kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_distances_s>())).values as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_distances_s),
            "::",
            stringify!(values)
        )
    );
}
pub const hwloc_distances_kind_e_HWLOC_DISTANCES_KIND_FROM_OS: hwloc_distances_kind_e = 1;
pub const hwloc_distances_kind_e_HWLOC_DISTANCES_KIND_FROM_USER: hwloc_distances_kind_e = 2;
pub const hwloc_distances_kind_e_HWLOC_DISTANCES_KIND_MEANS_LATENCY: hwloc_distances_kind_e = 4;
pub const hwloc_distances_kind_e_HWLOC_DISTANCES_KIND_MEANS_BANDWIDTH: hwloc_distances_kind_e = 8;
pub const hwloc_distances_kind_e_HWLOC_DISTANCES_KIND_HETEROGENEOUS_TYPES: hwloc_distances_kind_e =
    16;
pub type hwloc_distances_kind_e = ::std::os::raw::c_uint;
extern "C" {
    pub fn hwloc_distances_get(
        topology: hwloc_topology_t,
        nr: *mut ::std::os::raw::c_uint,
        distances: *mut *mut hwloc_distances_s,
        kind: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_distances_get_by_depth(
        topology: hwloc_topology_t,
        depth: ::std::os::raw::c_int,
        nr: *mut ::std::os::raw::c_uint,
        distances: *mut *mut hwloc_distances_s,
        kind: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_distances_get_by_type(
        topology: hwloc_topology_t,
        type_: hwloc_obj_type_t,
        nr: *mut ::std::os::raw::c_uint,
        distances: *mut *mut hwloc_distances_s,
        kind: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_distances_get_by_name(
        topology: hwloc_topology_t,
        name: *const ::std::os::raw::c_char,
        nr: *mut ::std::os::raw::c_uint,
        distances: *mut *mut hwloc_distances_s,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_distances_get_name(
        topology: hwloc_topology_t,
        distances: *mut hwloc_distances_s,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hwloc_distances_release(topology: hwloc_topology_t, distances: *mut hwloc_distances_s);
}
pub const hwloc_distances_transform_e_HWLOC_DISTANCES_TRANSFORM_REMOVE_NULL:
    hwloc_distances_transform_e = 0;
pub const hwloc_distances_transform_e_HWLOC_DISTANCES_TRANSFORM_LINKS: hwloc_distances_transform_e =
    1;
pub const hwloc_distances_transform_e_HWLOC_DISTANCES_TRANSFORM_MERGE_SWITCH_PORTS:
    hwloc_distances_transform_e = 2;
pub const hwloc_distances_transform_e_HWLOC_DISTANCES_TRANSFORM_TRANSITIVE_CLOSURE:
    hwloc_distances_transform_e = 3;
pub type hwloc_distances_transform_e = ::std::os::raw::c_uint;
extern "C" {
    pub fn hwloc_distances_transform(
        topology: hwloc_topology_t,
        distances: *mut hwloc_distances_s,
        transform: hwloc_distances_transform_e,
        transform_attr: *mut ::std::os::raw::c_void,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
pub type hwloc_distances_add_handle_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn hwloc_distances_add_create(
        topology: hwloc_topology_t,
        name: *const ::std::os::raw::c_char,
        kind: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> hwloc_distances_add_handle_t;
}
extern "C" {
    pub fn hwloc_distances_add_values(
        topology: hwloc_topology_t,
        handle: hwloc_distances_add_handle_t,
        nbobjs: ::std::os::raw::c_uint,
        objs: *mut hwloc_obj_t,
        values: *mut hwloc_uint64_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
pub const hwloc_distances_add_flag_e_HWLOC_DISTANCES_ADD_FLAG_GROUP: hwloc_distances_add_flag_e = 1;
pub const hwloc_distances_add_flag_e_HWLOC_DISTANCES_ADD_FLAG_GROUP_INACCURATE:
    hwloc_distances_add_flag_e = 2;
pub type hwloc_distances_add_flag_e = ::std::os::raw::c_uint;
extern "C" {
    pub fn hwloc_distances_add_commit(
        topology: hwloc_topology_t,
        handle: hwloc_distances_add_handle_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_distances_remove(topology: hwloc_topology_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_distances_remove_by_depth(
        topology: hwloc_topology_t,
        depth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_distances_release_remove(
        topology: hwloc_topology_t,
        distances: *mut hwloc_distances_s,
    ) -> ::std::os::raw::c_int;
}
pub const hwloc_topology_diff_obj_attr_type_e_HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_SIZE:
    hwloc_topology_diff_obj_attr_type_e = 0;
pub const hwloc_topology_diff_obj_attr_type_e_HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_NAME:
    hwloc_topology_diff_obj_attr_type_e = 1;
pub const hwloc_topology_diff_obj_attr_type_e_HWLOC_TOPOLOGY_DIFF_OBJ_ATTR_INFO:
    hwloc_topology_diff_obj_attr_type_e = 2;
pub type hwloc_topology_diff_obj_attr_type_e = ::std::os::raw::c_uint;
pub use self::hwloc_topology_diff_obj_attr_type_e as hwloc_topology_diff_obj_attr_type_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_topology_diff_obj_attr_u {
    pub generic: hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s,
    pub uint64: hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s,
    pub string: hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s {
    pub type_: hwloc_topology_diff_obj_attr_type_t,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s,
            >()))
            .type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_generic_s),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s {
    pub type_: hwloc_topology_diff_obj_attr_type_t,
    pub index: hwloc_uint64_t,
    pub oldvalue: hwloc_uint64_t,
    pub newvalue: hwloc_uint64_t,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s>(
        ),
        32usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s,
            >()))
            .type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s,
            >()))
            .index as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s,
            >()))
            .oldvalue as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s),
            "::",
            stringify!(oldvalue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s,
            >()))
            .newvalue as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_uint64_s),
            "::",
            stringify!(newvalue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s {
    pub type_: hwloc_topology_diff_obj_attr_type_t,
    pub name: *mut ::std::os::raw::c_char,
    pub oldvalue: *mut ::std::os::raw::c_char,
    pub newvalue: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s>(
        ),
        32usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s,
            >()))
            .type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s,
            >()))
            .name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s,
            >()))
            .oldvalue as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s),
            "::",
            stringify!(oldvalue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s,
            >()))
            .newvalue as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u_hwloc_topology_diff_obj_attr_string_s),
            "::",
            stringify!(newvalue)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_obj_attr_u() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_obj_attr_u>(),
        32usize,
        concat!("Size of: ", stringify!(hwloc_topology_diff_obj_attr_u))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_obj_attr_u>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_topology_diff_obj_attr_u))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_obj_attr_u>())).generic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_obj_attr_u>())).uint64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u),
            "::",
            stringify!(uint64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_obj_attr_u>())).string as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_obj_attr_u),
            "::",
            stringify!(string)
        )
    );
}
pub const hwloc_topology_diff_type_e_HWLOC_TOPOLOGY_DIFF_OBJ_ATTR: hwloc_topology_diff_type_e = 0;
pub const hwloc_topology_diff_type_e_HWLOC_TOPOLOGY_DIFF_TOO_COMPLEX: hwloc_topology_diff_type_e =
    1;
pub type hwloc_topology_diff_type_e = ::std::os::raw::c_uint;
pub use self::hwloc_topology_diff_type_e as hwloc_topology_diff_type_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union hwloc_topology_diff_u {
    pub generic: hwloc_topology_diff_u_hwloc_topology_diff_generic_s,
    pub obj_attr: hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s,
    pub too_complex: hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_diff_u_hwloc_topology_diff_generic_s {
    pub type_: hwloc_topology_diff_type_t,
    pub next: *mut hwloc_topology_diff_u,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_u_hwloc_topology_diff_generic_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_u_hwloc_topology_diff_generic_s>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_generic_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_u_hwloc_topology_diff_generic_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_generic_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_generic_s>())).type_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_generic_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_generic_s>())).next
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_generic_s),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s {
    pub type_: hwloc_topology_diff_type_t,
    pub next: *mut hwloc_topology_diff_u,
    pub obj_depth: ::std::os::raw::c_int,
    pub obj_index: ::std::os::raw::c_uint,
    pub diff: hwloc_topology_diff_obj_attr_u,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>())).type_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>())).next
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>()))
                .obj_depth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s),
            "::",
            stringify!(obj_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>()))
                .obj_index as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s),
            "::",
            stringify!(obj_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s>())).diff
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_obj_attr_s),
            "::",
            stringify!(diff)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s {
    pub type_: hwloc_topology_diff_type_t,
    pub next: *mut hwloc_topology_diff_u,
    pub obj_depth: ::std::os::raw::c_int,
    pub obj_index: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>()))
                .type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>())).next
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>()))
                .obj_depth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s),
            "::",
            stringify!(obj_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s>()))
                .obj_index as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u_hwloc_topology_diff_too_complex_s),
            "::",
            stringify!(obj_index)
        )
    );
}
#[test]
fn bindgen_test_layout_hwloc_topology_diff_u() {
    assert_eq!(
        ::std::mem::size_of::<hwloc_topology_diff_u>(),
        56usize,
        concat!("Size of: ", stringify!(hwloc_topology_diff_u))
    );
    assert_eq!(
        ::std::mem::align_of::<hwloc_topology_diff_u>(),
        8usize,
        concat!("Alignment of ", stringify!(hwloc_topology_diff_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_topology_diff_u>())).generic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u),
            "::",
            stringify!(generic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hwloc_topology_diff_u>())).obj_attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u),
            "::",
            stringify!(obj_attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hwloc_topology_diff_u>())).too_complex as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hwloc_topology_diff_u),
            "::",
            stringify!(too_complex)
        )
    );
}
pub type hwloc_topology_diff_t = *mut hwloc_topology_diff_u;
extern "C" {
    pub fn hwloc_topology_diff_build(
        topology: hwloc_topology_t,
        newtopology: hwloc_topology_t,
        flags: ::std::os::raw::c_ulong,
        diff: *mut hwloc_topology_diff_t,
    ) -> ::std::os::raw::c_int;
}
pub const hwloc_topology_diff_apply_flags_e_HWLOC_TOPOLOGY_DIFF_APPLY_REVERSE:
    hwloc_topology_diff_apply_flags_e = 1;
pub type hwloc_topology_diff_apply_flags_e = ::std::os::raw::c_uint;
extern "C" {
    pub fn hwloc_topology_diff_apply(
        topology: hwloc_topology_t,
        diff: hwloc_topology_diff_t,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_topology_diff_destroy(diff: hwloc_topology_diff_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_topology_diff_load_xml(
        xmlpath: *const ::std::os::raw::c_char,
        diff: *mut hwloc_topology_diff_t,
        refname: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_topology_diff_export_xml(
        diff: hwloc_topology_diff_t,
        refname: *const ::std::os::raw::c_char,
        xmlpath: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_topology_diff_load_xmlbuffer(
        xmlbuffer: *const ::std::os::raw::c_char,
        buflen: ::std::os::raw::c_int,
        diff: *mut hwloc_topology_diff_t,
        refname: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_topology_diff_export_xmlbuffer(
        diff: hwloc_topology_diff_t,
        refname: *const ::std::os::raw::c_char,
        xmlbuffer: *mut *mut ::std::os::raw::c_char,
        buflen: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hwloc_distances_add(
        topology: hwloc_topology_t,
        nbobjs: ::std::os::raw::c_uint,
        objs: *mut hwloc_obj_t,
        values: *mut hwloc_uint64_t,
        kind: ::std::os::raw::c_ulong,
        flags: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
